<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quantum Particle Network Simulator with AI Chat</title>
  <!-- Load Three.js as ES Module from CDN -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.module.min.js"
      }
    }
  </script>
  <!-- Load GSAP for animations -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>
  <!-- Load JetBrains Mono font -->
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* Neo-futuristic design system with refined glassmorphism */
    :root {
      /* Updated color palette - more gray/black based tones */
      --primary: #484848;
      --primary-light: #686868;
      --primary-dark: #282828;
      --secondary: #3d3d3d;
      --tertiary: #989898;
      --accent: #c0c0c0;
      
      /* Dark, rich background */
      --background: #121212;
      --background-darker: #0a0a0a;
      --background-lighter: #1a1a1a;
      
      /* Panel styles with enhanced glassmorphism */
      --panel-bg: rgba(18, 18, 18, 0.75);
      --panel-border: rgba(72, 72, 72, 0.25);
      --panel-glow: rgba(150, 150, 150, 0.12);
      --panel-accent: rgba(72, 72, 72, 0.15);
      
      /* Control elements */
      --slider-bg: rgba(72, 72, 72, 0.15);
      --slider-thumb: var(--primary);
      --slider-track: rgba(72, 72, 72, 0.3);
      
      /* Typography */
      --text-primary: rgba(255, 255, 255, 0.95);
      --text-secondary: rgba(255, 255, 255, 0.75);
      --text-tertiary: rgba(255, 255, 255, 0.5);
      --text-accent: var(--primary-light);
      
      /* Spacing - precise 4px grid system */
      --space-1: 4px;
      --space-2: 8px;
      --space-3: 12px;
      --space-4: 16px;
      --space-5: 20px;
      --space-6: 24px;
      --space-8: 32px;
      --space-10: 40px;
      
      /* Blur effects */
      --blur-sm: 10px;
      --blur-md: 15px;
      --blur-lg: 25px;
      
      /* Transitions */
      --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
      --transition-normal: 250ms cubic-bezier(0.4, 0, 0.2, 1);
      --transition-slow: 350ms cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    /* Global styles */
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: var(--background);
      font-family: 'JetBrains Mono', monospace;
      color: var(--text-primary);
      cursor: default;
      /* Add subtle noise texture */
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.75' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.025'/%3E%3C/svg%3E");
      background-repeat: repeat;
      background-size: 200px;
    }
    
    #particleCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    /* Grid overlay */
    .grid-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background-image: 
        linear-gradient(to right, rgba(58, 123, 213, 0.03) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(58, 123, 213, 0.03) 1px, transparent 1px);
      background-size: 20px 20px;
      opacity: 0.5;
      z-index: 1;
    }
    
    /* Enhanced glassmorphic panels - SMALLER SIZE */
    .control-panel {
      position: absolute;
      padding: var(--space-4);
      background: var(--panel-bg);
      border-radius: 12px;
      z-index: 10;
      border: 1px solid var(--panel-border);
      box-shadow: 0 4px 20px var(--panel-glow), inset 0 0 0 1px rgba(255, 255, 255, 0.03);
      backdrop-filter: blur(var(--blur-md));
      transition: all var(--transition-normal);
      /* Add neo-futuristic corner shapes */
      position: relative;
      overflow: hidden;
      /* Smaller size */
      transform-origin: top right;
      opacity: 0.85;
    }
    
    /* Corner decorations */
    .control-panel::before,
    .control-panel::after {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      border-color: var(--primary);
      opacity: 0.4;
      transition: all var(--transition-normal);
    }
    
    .control-panel::before {
      top: 0;
      left: 0;
      border-top: 1px solid;
      border-left: 1px solid;
      border-top-left-radius: 6px;
    }
    
    .control-panel::after {
      bottom: 0;
      right: 0;
      border-bottom: 1px solid;
      border-right: 1px solid;
      border-bottom-right-radius: 6px;
    }
    
    .control-panel:hover {
      box-shadow: 0 8px 30px var(--panel-glow), inset 0 0 0 1px rgba(255, 255, 255, 0.05);
      opacity: 1;
    }
    
    .control-panel:hover::before,
    .control-panel:hover::after {
      width: 24px;
      height: 24px;
      opacity: 0.6;
    }
    
    /* Panel header styling - SMALLER */
    .control-panel h3 {
      margin-top: 0;
      margin-bottom: var(--space-3);
      font-size: 13px;
      color: var(--tertiary);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      text-shadow: 0 0 15px rgba(0, 210, 255, 0.5);
      display: flex;
      align-items: center;
      position: relative;
    }
    
    /* Add neo-futuristic prefix to headers */
    .control-panel h3::before {
      content: '//';
      margin-right: var(--space-2);
      color: var(--primary-light);
      opacity: 0.7;
      font-size: 11px;
    }
    
    /* Panel positioning with increased spacing */
    .shape-controls {
      bottom: var(--space-4);
      left: var(--space-4);
      transition: transform 0.3s ease, opacity 0.3s ease;
    }
    
    .color-controls {
      bottom: var(--space-4);
      right: var(--space-4);
      transition: transform 0.3s ease, opacity 0.3s ease;
    }
    
    .settings-panel {
      top: var(--space-4);
      right: var(--space-4);
      width: 240px;
      max-height: 70vh;
      overflow-y: auto;
      overflow-x: hidden;
      transform: scale(0.85);
      transform-origin: top right;
      transition: transform 0.3s ease, opacity 0.3s ease;
    }
    
    /* UI States - Hide panels when minimal mode is active */
    body.minimal-ui .control-panel:not(.active-panel) {
      opacity: 0;
      pointer-events: none;
      transform: scale(0.9);
    }
    
    body.minimal-ui .control-panel.active-panel {
      opacity: 1;
      pointer-events: auto;
    }
    
    /* Toggle button for hiding UI */
    #toggleMinimalUI {
      position: fixed;
      top: var(--space-4);
      left: var(--space-4);
      z-index: 1000;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      color: var(--tertiary);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 2px 10px var(--panel-glow);
      transition: all 0.2s ease;
    }
    
    #toggleMinimalUI:hover {
      transform: scale(1.1);
      box-shadow: 0 2px 15px var(--panel-glow);
    }
    
    /* Custom scrollbar */
    .settings-panel::-webkit-scrollbar {
      width: 4px;
    }
    
    .settings-panel::-webkit-scrollbar-track {
      background: rgba(10, 14, 23, 0.4);
      border-radius: 2px;
    }
    
    .settings-panel::-webkit-scrollbar-thumb {
      background: var(--primary);
      border-radius: 2px;
      opacity: 0.7;
    }
    
    .settings-panel::-webkit-scrollbar-thumb:hover {
      background: var(--primary-light);
    }
    
    /* Button styling with refined futuristic design - SMALLER */
    .button-group {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
    }
    
    button {
      padding: var(--space-2) var(--space-3);
      background: rgba(10, 14, 23, 0.8);
      border: 1px solid var(--panel-border);
      border-radius: 6px;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 11px;
      transition: all var(--transition-fast);
      font-family: 'JetBrains Mono', monospace;
      letter-spacing: 0.5px;
      position: relative;
      overflow: hidden;
    }
    
    /* Button hover effect */
    button:hover {
      background: rgba(58, 123, 213, 0.15);
      border-color: var(--primary-light);
      color: var(--text-primary);
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(58, 123, 213, 0.2);
    }
    
    /* Button active state */
    button.active {
      background: rgba(58, 123, 213, 0.25);
      border: 1px solid var(--primary-light);
      box-shadow: 0 0 12px rgba(58, 123, 213, 0.3);
      color: var(--tertiary);
    }
    
    /* Add subtle glow effect on active buttons */
    button.active::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(circle at center, rgba(0, 210, 255, 0.15), transparent 70%);
      opacity: 0.6;
      pointer-events: none;
    }
    
    /* Button click effect */
    button:active {
      transform: translateY(0);
    }
    
    /* Add digital line effect to buttons */
    button::after {
      content: '';
      position: absolute;
      bottom: 3px;
      left: 10%;
      width: 80%;
      height: 1px;
      background: linear-gradient(
        to right,
        transparent,
        var(--primary) 20%,
        var(--primary) 80%,
        transparent
      );
      opacity: 0.3;
      transition: all var(--transition-normal);
    }
    
    button:hover::after {
      opacity: 0.6;
    }
    
    /* Slider styling with more precise controls - SMALLER */
    .slider-container {
      margin-bottom: var(--space-4);
      position: relative;
    }
    
    .slider-container.active-slider {
      z-index: 100;
    }
    
    .slider-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: var(--space-1);
      font-size: 11px;
    }
    
    .slider-value {
      color: var(--tertiary);
      font-family: 'JetBrains Mono', monospace;
      opacity: 0.9;
      background: rgba(0, 210, 255, 0.1);
      padding: 1px 4px;
      border-radius: 3px;
      min-width: 36px;
      text-align: center;
    }
    
    label {
      color: var(--text-secondary);
      font-size: 11px;
      display: flex;
      align-items: center;
    }
    
    /* Add terminal-like prefix to labels */
    label::before {
      content: '>';
      margin-right: var(--space-1);
      color: var(--primary-light);
      opacity: 0.7;
      font-size: 10px;
    }
    
    /* Enhanced slider styling */
    input[type="range"] {
      width: 100%;
      height: 3px;
      background: var(--slider-bg);
      border-radius: 2px;
      appearance: none;
      outline: none;
      cursor: pointer;
      position: relative;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--slider-thumb);
      cursor: pointer;
      box-shadow: 0 0 8px rgba(58, 123, 213, 0.5);
      transition: all var(--transition-fast);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 12px rgba(94, 158, 255, 0.7);
    }
    
    /* Slider track fill effect */
    input[type="range"] {
      background: linear-gradient(to right, var(--primary) 0%, var(--primary) 50%, var(--slider-bg) 50%, var(--slider-bg) 100%);
    }
    
    /* Fullscreen button */
    .fullscreen-button {
      position: absolute;
      top: var(--space-4);
      left: var(--space-10);
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--panel-bg);
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 1px solid var(--panel-border);
      box-shadow: 0 2px 10px var(--panel-glow);
      backdrop-filter: blur(var(--blur-sm));
      color: var(--tertiary);
      font-size: 16px;
      cursor: pointer;
      transition: all var(--transition-normal);
    }
    
    .fullscreen-button:hover {
      background: rgba(58, 123, 213, 0.15);
      border-color: var(--primary-light);
      transform: scale(1.1);
      box-shadow: 0 3px 15px rgba(58, 123, 213, 0.25);
    }
    
    /* Logo styling - SMALLER */
    .quantum-logo {
      position: fixed;
      bottom: var(--space-4);
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      color: var(--text-tertiary);
      text-transform: uppercase;
      letter-spacing: 3px;
      opacity: 0.4;
      z-index: 10;
      text-shadow: 0 0 12px rgba(0, 210, 255, 0.6);
      transition: all var(--transition-normal);
      font-family: 'JetBrains Mono', monospace;
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }
    
    .quantum-logo:hover {
      opacity: 0.7;
      letter-spacing: 4px;
    }
    
    /* Add terminal cursor to logo */
    .quantum-logo::after {
      content: '|';
      animation: blink 1.2s step-end infinite;
      color: var(--tertiary);
    }
    
    /* Hide logo in minimal mode */
    body.minimal-ui .quantum-logo {
      opacity: 0;
    }
    
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }
    
    /* Tab styling - SMALLER */
    .tabs {
      display: flex;
      margin-bottom: var(--space-3);
      border-bottom: 1px solid rgba(58, 123, 213, 0.2);
    }
    
    .tab {
      padding: var(--space-2) var(--space-3);
      background: transparent;
      border: none;
      border-bottom: 2px solid transparent;
      border-radius: 0;
      color: var(--text-tertiary);
      margin-right: var(--space-2);
      position: relative;
      font-size: 10px;
    }
    
    .tab:hover {
      background: transparent;
      color: var(--text-secondary);
      transform: none;
    }
    
    .tab.active {
      color: var(--tertiary);
      border-bottom: 2px solid var(--tertiary);
      background: transparent;
      box-shadow: none;
    }
    
    /* Add subtle glow to active tab */
    .tab.active::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      width: 100%;
      height: 2px;
      background: var(--tertiary);
      box-shadow: 0 0 8px var(--tertiary);
      border-radius: 1px;
    }

    /* Stats display - SMALLER */
    .stats-display {
      position: absolute;
      top: var(--space-4);
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: var(--space-3);
      align-items: center;
      z-index: 100;
      background: var(--panel-bg);
      padding: var(--space-2) var(--space-3);
      border-radius: 8px;
      border: 1px solid var(--panel-border);
      box-shadow: 0 2px 10px var(--panel-glow);
      backdrop-filter: blur(var(--blur-sm));
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    
    /* Hide stats in minimal mode */
    body.minimal-ui .stats-display {
      opacity: 0;
      transform: translateX(-50%) translateY(-10px);
      pointer-events: none;
    }
    
    .stat-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--space-1);
    }
    
    .stat-label {
      font-size: 8px;
      color: var(--text-tertiary);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .stat-value {
      font-size: 10px;
      color: var(--tertiary);
      font-weight: 500;
    }
    
    /* Digital readouts - SMALLER */
    .digital-readout {
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      background: rgba(10, 14, 23, 0.8);
      border: 1px solid var(--panel-border);
      border-radius: 3px;
      padding: var(--space-1) var(--space-2);
      color: var(--tertiary);
      display: inline-block;
      margin-right: var(--space-1);
      position: relative;
      min-width: 40px;
      text-align: center;
    }
    
    /* Loading screen */
    .loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--background);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      transition: opacity var(--transition-slow);
      /* Add subtle noise texture */
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.75' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.025'/%3E%3C/svg%3E");
      background-repeat: repeat;
      background-size: 200px;
    }
    
    .loading-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    /* Enhanced loading spinner */
    .loading-spinner {
      width: 60px;
      height: 60px;
      position: relative;
    }
    
    .loading-spinner::before,
    .loading-spinner::after {
      content: '';
      position: absolute;
      border-radius: 50%;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    .loading-spinner::before {
      border: 2px solid rgba(58, 123, 213, 0.1);
    }
    
    .loading-spinner::after {
      border: 2px solid transparent;
      border-top-color: var(--tertiary);
      animation: spin 1s linear infinite;
      box-shadow: 0 0 12px rgba(0, 210, 255, 0.5);
    }
    
    /* Secondary spinner ring */
    .loading-spinner::before {
      border: 2px solid rgba(58, 123, 213, 0.1);
    }
    
    .loading-spinner::after {
      width: calc(100% - 12px);
      height: calc(100% - 12px);
      top: 6px;
      left: 6px;
      border: 2px solid transparent;
      border-top-color: var(--tertiary);
      animation: spin 0.8s linear infinite;
      box-shadow: 0 0 12px rgba(0, 210, 255, 0.5);
    }
    
    /* Additional spinner element */
    .loading-spinner-inner {
      position: absolute;
      width: calc(100% - 24px);
      height: calc(100% - 24px);
      top: 12px;
      left: 12px;
      border: 1px solid transparent;
      border-right-color: var(--primary-light);
      border-radius: 50%;
      animation: spin 1.2s linear infinite reverse;
    }
    
    .loading-text {
      margin-top: var(--space-6);
      font-size: 14px;
      color: var(--tertiary);
      text-transform: uppercase;
      letter-spacing: 3px;
      font-family: 'JetBrains Mono', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--space-2);
    }
    
    /* Add animated underline to loading text */
    .loading-text::after {
      content: '';
      display: block;
      width: 100%;
      height: 1px;
      background: linear-gradient(to right, transparent, var(--tertiary), transparent);
      margin-top: var(--space-2);
      opacity: 0.5;
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.2; }
      50% { opacity: 0.8; }
    }
    
    /* Debug console - SMALLER */
    #debugConsole {
      position: fixed;
      bottom: var(--space-4);
      left: 50%;
      transform: translateX(-50%);
      width: 40%;
      max-height: 150px;
      background: rgba(10, 14, 23, 0.85);
      border: 1px solid var(--panel-border);
      border-radius: 8px;
      color: #00d2ff;
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      padding: var(--space-3);
      overflow-y: auto;
      z-index: 1000;
      display: none;
      backdrop-filter: blur(var(--blur-sm));
    }
    
    /* Hide debug in minimal mode */
    body.minimal-ui #debugConsole {
      opacity: 0;
      pointer-events: none;
    }
    
    .debug-message {
      margin: 2px 0;
      padding: 1px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.07);
      font-family: 'JetBrains Mono', monospace;
      position: relative;
      padding-left: var(--space-4);
    }
    
    /* Add terminal prefix to debug messages */
    .debug-message::before {
      content: '>';
      position: absolute;
      left: 0;
      color: var(--tertiary);
      opacity: 0.7;
    }
    
    .debug-error {
      color: #ff4d88;
    }
    
    .debug-warning {
      color: #ffcc66;
    }
    
    .debug-info {
      color: #00d2ff;
    }
    
    #particleCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    /* Grid overlay */
    .grid-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background-image: 
        linear-gradient(to right, rgba(58, 123, 213, 0.04) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(58, 123, 213, 0.04) 1px, transparent 1px);
      background-size: 20px 20px;
      opacity: 0.5;
      z-index: 1;
    }
    
    /* Enhanced glassmorphic panels */
    .control-panel {
      position: absolute;
      padding: var(--space-6);
      background: var(--panel-bg);
      border-radius: 16px;
      z-index: 10;
      border: 1px solid var(--panel-border);
      box-shadow: 0 4px 30px var(--panel-glow), inset 0 0 0 1px rgba(255, 255, 255, 0.03);
      backdrop-filter: blur(var(--blur-md));
      transition: all var(--transition-normal);
      /* Add neo-futuristic corner shapes */
      position: relative;
      overflow: hidden;
    }
    
    /* Corner decorations */
    .control-panel::before,
    .control-panel::after {
      content: '';
      position: absolute;
      width: 30px;
      height: 30px;
      border-color: var(--primary);
      opacity: 0.4;
      transition: all var(--transition-normal);
    }
    
    .control-panel::before {
      top: 0;
      left: 0;
      border-top: 2px solid;
      border-left: 2px solid;
      border-top-left-radius: 8px;
    }
    
    .control-panel::after {
      bottom: 0;
      right: 0;
      border-bottom: 2px solid;
      border-right: 2px solid;
      border-bottom-right-radius: 8px;
    }
    
    .control-panel:hover {
      box-shadow: 0 8px 40px var(--panel-glow), inset 0 0 0 1px rgba(255, 255, 255, 0.05);
    }
    
    .control-panel:hover::before,
    .control-panel:hover::after {
      width: 40px;
      height: 40px;
      opacity: 0.6;
    }
    
    /* Panel header styling */
    .control-panel h3 {
      margin-top: 0;
      margin-bottom: var(--space-5);
      font-size: 16px;
      color: var(--tertiary);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-shadow: 0 0 15px rgba(0, 210, 255, 0.5);
      display: flex;
      align-items: center;
      position: relative;
    }
    
    /* Add neo-futuristic prefix to headers */
    .control-panel h3::before {
      content: '//';
      margin-right: var(--space-3);
      color: var(--primary-light);
      opacity: 0.7;
      font-size: 14px;
    }
    
    /* Panel positioning with increased spacing */
    .shape-controls {
      bottom: var(--space-4);
      left: var(--space-4);
      max-width: 280px;
      transform: scale(0.85);
      transform-origin: bottom left;
    }
    
    .color-controls {
      bottom: var(--space-4);
      right: var(--space-4);
      max-width: 280px;
      transform: scale(0.85);
      transform-origin: bottom right;
    }
    
    .settings-panel {
      top: var(--space-4);
      right: var(--space-4);
      width: 240px;
      max-height: 70vh;
      overflow-y: auto;
      overflow-x: hidden;
      transform: scale(0.85);
      transform-origin: top right;
    }
    
    /* Color customizer styles */
    .color-customizer {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 12px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      margin-top: 12px;
    }
    
    .color-slider-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .color-slider-group label {
      font-size: 12px;
      color: var(--text-secondary);
      margin-bottom: 2px;
    }
    
    .color-slider-group input[type="color"] {
      width: 100%;
      height: 24px;
      border: 1px solid var(--panel-border);
      background: transparent;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .color-slider-group input[type="range"] {
      width: 100%;
      -webkit-appearance: none;
      height: 6px;
      background: var(--slider-bg);
      border-radius: 3px;
      outline: none;
    }
    
    .color-slider-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      border: none;
    }
    
    /* Audio controls styling */
    .audio-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .audio-button {
      padding: 8px 12px;
      background: var(--panel-accent);
      border: 1px solid var(--panel-border);
      border-radius: 6px;
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .audio-button:hover {
      background: var(--primary);
      color: white;
    }
    
    .audio-button svg {
      opacity: 0.8;
    }
    
    .audio-button.active {
      background: var(--primary);
      color: white;
      box-shadow: 0 0 8px var(--primary);
    }
    
    .harmonic-controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 16px;
    }
    
    .frequency-selector {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .frequency-selector label,
    .harmonic-series label {
      font-size: 12px;
      color: var(--text-secondary);
    }
    
    .frequency-selector select {
      background: var(--panel-accent);
      border: 1px solid var(--panel-border);
      border-radius: 4px;
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      padding: 4px 8px;
    }
    
    .harmonic-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 4px;
    }
    
    .harmonic-preset {
      background: var(--panel-accent);
      border: 1px solid var(--panel-border);
      border-radius: 4px;
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      padding: 4px 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .harmonic-preset:hover {
      background: var(--primary);
      color: white;
    }
    
    .harmonic-preset.active {
      background: var(--primary);
      color: white;
    }
    
    .play-button {
      align-self: flex-start;
      margin-top: 4px;
    }
    
    .audio-visualization {
      margin-top: 12px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 6px;
      padding: 6px;
      border: 1px solid var(--panel-border);
    }
    
    #audioVisualizerCanvas {
      width: 100%;
      height: 80px;
      display: block;
    }
    
    /* Custom scrollbar */
    .settings-panel::-webkit-scrollbar {
      width: 6px;
    }
    
    .settings-panel::-webkit-scrollbar-track {
      background: rgba(10, 14, 23, 0.4);
      border-radius: 3px;
    }
    
    .settings-panel::-webkit-scrollbar-thumb {
      background: var(--primary);
      border-radius: 3px;
      opacity: 0.7;
    }
    
    .settings-panel::-webkit-scrollbar-thumb:hover {
      background: var(--primary-light);
    }
    
    /* Button styling with refined futuristic design */
    .button-group {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-3);
    }
    
    button {
      padding: var(--space-3) var(--space-5);
      background: rgba(10, 14, 23, 0.8);
      border: 1px solid var(--panel-border);
      border-radius: 8px;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 13px;
      transition: all var(--transition-fast);
      font-family: 'JetBrains Mono', monospace;
      letter-spacing: 0.5px;
      position: relative;
      overflow: hidden;
    }
    
    /* Button hover effect */
    button:hover {
      background: rgba(58, 123, 213, 0.15);
      border-color: var(--primary-light);
      color: var(--text-primary);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(58, 123, 213, 0.2);
    }
    
    /* Button active state */
    button.active {
      background: rgba(58, 123, 213, 0.25);
      border: 1px solid var(--primary-light);
      box-shadow: 0 0 15px rgba(58, 123, 213, 0.3);
      color: var(--tertiary);
    }
    
    /* Add subtle glow effect on active buttons */
    button.active::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(circle at center, rgba(0, 210, 255, 0.15), transparent 70%);
      opacity: 0.6;
      pointer-events: none;
    }
    
    /* Button click effect */
    button:active {
      transform: translateY(0);
    }
    
    /* Add digital line effect to buttons */
    button::after {
      content: '';
      position: absolute;
      bottom: 4px;
      left: 10%;
      width: 80%;
      height: 1px;
      background: linear-gradient(
        to right,
        transparent,
        var(--primary) 20%,
        var(--primary) 80%,
        transparent
      );
      opacity: 0.3;
      transition: all var(--transition-normal);
    }
    
    button:hover::after {
      opacity: 0.6;
    }
    
    /* Slider styling with more precise controls */
    .slider-container {
      margin-bottom: var(--space-6);
    }
    
    .slider-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: var(--space-2);
      font-size: 13px;
    }
    
    .slider-value {
      color: var(--tertiary);
      font-family: 'JetBrains Mono', monospace;
      opacity: 0.9;
      background: rgba(0, 210, 255, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
      min-width: 40px;
      text-align: center;
    }
    
    label {
      color: var(--text-secondary);
      font-size: 13px;
      display: flex;
      align-items: center;
    }
    
    /* Add terminal-like prefix to labels */
    label::before {
      content: '>';
      margin-right: var(--space-2);
      color: var(--primary-light);
      opacity: 0.7;
      font-size: 11px;
    }
    
    /* Enhanced slider styling */
    input[type="range"] {
      width: 100%;
      height: 4px;
      background: var(--slider-bg);
      border-radius: 2px;
      appearance: none;
      outline: none;
      cursor: pointer;
      position: relative;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--slider-thumb);
      cursor: pointer;
      box-shadow: 0 0 10px rgba(58, 123, 213, 0.5);
      transition: all var(--transition-fast);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 15px rgba(94, 158, 255, 0.7);
    }
    
    /* Slider track fill effect */
    input[type="range"] {
      background: linear-gradient(to right, var(--primary) 0%, var(--primary) 50%, var(--slider-bg) 50%, var(--slider-bg) 100%);
    }
    
    /* Fullscreen button */
    .fullscreen-button {
      position: absolute;
      top: var(--space-8);
      left: var(--space-8);
      z-index: 100;
      display: flex;
      align-items: center;
      gap: var(--space-3);
      background: var(--panel-bg);
      padding: var(--space-3) var(--space-5);
      border-radius: 10px;
      border: 1px solid var(--panel-border);
      box-shadow: 0 4px 15px var(--panel-glow);
      backdrop-filter: blur(var(--blur-sm));
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      cursor: pointer;
      transition: all var(--transition-normal);
    }
    
    .fullscreen-button:hover {
      background: rgba(58, 123, 213, 0.15);
      border-color: var(--primary-light);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(58, 123, 213, 0.25);
    }
    
    /* Add icon to fullscreen button */
    .fullscreen-button::before {
      content: '⤢';
      font-size: 16px;
      color: var(--tertiary);
    }
    
    /* Logo styling */
    .quantum-logo {
      position: fixed;
      bottom: var(--space-8);
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      color: var(--text-tertiary);
      text-transform: uppercase;
      letter-spacing: 4px;
      opacity: 0.6;
      z-index: 10;
      text-shadow: 0 0 15px rgba(0, 210, 255, 0.6);
      transition: all var(--transition-normal);
      font-family: 'JetBrains Mono', monospace;
      display: flex;
      align-items: center;
      gap: var(--space-3);
    }
    
    .quantum-logo:hover {
      opacity: 0.9;
      letter-spacing: 5px;
    }
    
    .with-ai-badge {
      display: inline-block;
      background: var(--tertiary);
      color: var(--background-darker);
      font-size: 10px;
      font-weight: 600;
      padding: 3px 6px;
      border-radius: 4px;
      letter-spacing: 0.5px;
      text-shadow: none;
      text-transform: none;
      animation: glow 1.5s infinite alternate;
      opacity: 0.9;
      vertical-align: middle;
      margin-left: 8px;
    }
    
    @keyframes glow {
      0% {
        box-shadow: 0 0 5px rgba(0, 210, 255, 0.6);
      }
      100% {
        box-shadow: 0 0 10px rgba(0, 210, 255, 0.9);
      }
    }
    
    /* Add terminal cursor to logo */
    .quantum-logo::after {
      content: '|';
      animation: blink 1.2s step-end infinite;
      color: var(--tertiary);
    }
    
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }
    
    /* Presets panel */
    .presets-panel {
      top: var(--space-8);
      left: var(--space-8);
      z-index: 90;
    }
    
    .preset-button {
      margin-right: var(--space-1);
      margin-bottom: var(--space-1);
      font-size: 12px;
    }
    
    /* Tab styling */
    .tabs {
      display: flex;
      margin-bottom: var(--space-5);
      border-bottom: 1px solid rgba(58, 123, 213, 0.2);
    }
    
    .tab {
      padding: var(--space-3) var(--space-4);
      background: transparent;
      border: none;
      border-bottom: 2px solid transparent;
      border-radius: 0;
      color: var(--text-tertiary);
      margin-right: var(--space-3);
      position: relative;
    }
    
    .tab:hover {
      background: transparent;
      color: var(--text-secondary);
      transform: none;
    }
    
    .tab.active {
      color: var(--tertiary);
      border-bottom: 2px solid var(--tertiary);
      background: transparent;
      box-shadow: none;
    }
    
    /* Add subtle glow to active tab */
    .tab.active::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      width: 100%;
      height: 2px;
      background: var(--tertiary);
      box-shadow: 0 0 10px var(--tertiary);
      border-radius: 1px;
    }

    /* Stats display */
    .stats-display {
      position: absolute;
      top: var(--space-8);
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: var(--space-4);
      align-items: center;
      z-index: 100;
      background: var(--panel-bg);
      padding: var(--space-3) var(--space-5);
      border-radius: 10px;
      border: 1px solid var(--panel-border);
      box-shadow: 0 4px 15px var(--panel-glow);
      backdrop-filter: blur(var(--blur-sm));
    }
    
    .stat-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--space-1);
    }
    
    .stat-label {
      font-size: 10px;
      color: var(--text-tertiary);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .stat-value {
      font-size: 14px;
      color: var(--tertiary);
      font-weight: 500;
    }
    
    /* Digital readouts */
    .digital-readout {
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      background: rgba(10, 14, 23, 0.8);
      border: 1px solid var(--panel-border);
      border-radius: 4px;
      padding: var(--space-1) var(--space-3);
      color: var(--tertiary);
      display: inline-block;
      margin-right: var(--space-2);
      position: relative;
      min-width: 60px;
      text-align: center;
    }
    
    /* Loading screen */
    .loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--background);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      transition: opacity var(--transition-slow);
      /* Add subtle noise texture */
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.75' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.025'/%3E%3C/svg%3E");
      background-repeat: repeat;
      background-size: 200px;
    }
    
    .loading-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    /* Enhanced loading spinner */
    .loading-spinner {
      width: 80px;
      height: 80px;
      position: relative;
    }
    
    .loading-spinner::before,
    .loading-spinner::after {
      content: '';
      position: absolute;
      border-radius: 50%;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    .loading-spinner::before {
      border: 3px solid rgba(58, 123, 213, 0.1);
    }
    
    .loading-spinner::after {
      border: 3px solid transparent;
      border-top-color: var(--tertiary);
      animation: spin 1s linear infinite;
      box-shadow: 0 0 15px rgba(0, 210, 255, 0.5);
    }
    
    /* Secondary spinner ring */
    .loading-spinner::before {
      border: 3px solid rgba(58, 123, 213, 0.1);
    }
    
    .loading-spinner::after {
      width: calc(100% - 16px);
      height: calc(100% - 16px);
      top: 8px;
      left: 8px;
      border: 3px solid transparent;
      border-top-color: var(--tertiary);
      animation: spin 0.8s linear infinite;
      box-shadow: 0 0 15px rgba(0, 210, 255, 0.5);
    }
    
    /* Additional spinner element */
    .loading-spinner-inner {
      position: absolute;
      width: calc(100% - 30px);
      height: calc(100% - 30px);
      top: 15px;
      left: 15px;
      border: 2px solid transparent;
      border-right-color: var(--primary-light);
      border-radius: 50%;
      animation: spin 1.2s linear infinite reverse;
    }
    
    .loading-text {
      margin-top: var(--space-8);
      font-size: 16px;
      color: var(--tertiary);
      text-transform: uppercase;
      letter-spacing: 3px;
      font-family: 'JetBrains Mono', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--space-3);
    }
    
    /* Add animated underline to loading text */
    .loading-text::after {
      content: '';
      display: block;
      width: 100%;
      height: 1px;
      background: linear-gradient(to right, transparent, var(--tertiary), transparent);
      margin-top: var(--space-3);
      opacity: 0.5;
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.2; }
      50% { opacity: 0.8; }
    }
    
    /* Debug console */
    #debugConsole {
      position: fixed;
      bottom: var(--space-8);
      left: 50%;
      transform: translateX(-50%);
      width: 50%;
      max-height: 200px;
      background: rgba(10, 14, 23, 0.85);
      border: 1px solid var(--panel-border);
      border-radius: 10px;
      color: #00d2ff;
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      padding: var(--space-4);
      overflow-y: auto;
      z-index: 1000;
      display: none;
      backdrop-filter: blur(var(--blur-sm));
    }
    
    .debug-message {
      margin: 2px 0;
      padding: 2px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.07);
      font-family: 'JetBrains Mono', monospace;
      position: relative;
      padding-left: var(--space-5);
    }
    
    /* Add terminal prefix to debug messages */
    .debug-message::before {
      content: '>';
      position: absolute;
      left: 0;
      color: var(--tertiary);
      opacity: 0.7;
    }
    
    .debug-error {
      color: #ff4d88;
    }
    
    .debug-warning {
      color: #ffcc66;
    }
    
    .debug-info {
      color: #00d2ff;
    }
    
    /* Chat Interface Styles */
    .chat-overlay {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 320px;
      height: 400px;
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 16px;
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), 0 0 16px var(--panel-glow);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      z-index: 1000;
      transform: translateY(120%);
      transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1);
      overflow: hidden;
      transform-origin: bottom right;
    }
    
    .chat-overlay.visible {
      transform: translateY(0);
    }
    
    .chat-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      border-bottom: 1px solid var(--panel-border);
      background: var(--panel-accent);
    }
    
    .chat-title {
      color: var(--text-primary);
      font-weight: 600;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .chat-close {
      background: none;
      border: none;
      color: var(--text-tertiary);
      cursor: pointer;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      transition: all 0.2s ease;
    }
    
    .chat-close:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-primary);
    }
    
    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      scroll-behavior: smooth;
    }
    
    .message {
      max-width: 85%;
      padding: 10px 14px;
      border-radius: 14px;
      font-size: 13px;
      line-height: 1.4;
      position: relative;
      animation: messageAppear 0.3s ease forwards;
    }
    
    @keyframes messageAppear {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .user-message {
      align-self: flex-end;
      background: var(--primary);
      color: white;
      border-bottom-right-radius: 4px;
    }
    
    .bot-message {
      align-self: flex-start;
      background: var(--panel-accent);
      color: var(--text-primary);
      border-bottom-left-radius: 4px;
    }
    
    .system-message {
      align-self: center;
      background: rgba(0, 0, 0, 0.2);
      color: var(--text-secondary);
      border-radius: 8px;
      font-size: 12px;
      width: fit-content;
      max-width: 90%;
      padding: 8px 12px;
    }
    
    .message-content {
      word-break: break-word;
    }
    
    .message-timestamp {
      position: absolute;
      bottom: -16px;
      font-size: 10px;
      color: var(--text-tertiary);
      white-space: nowrap;
    }
    
    .user-message .message-timestamp {
      right: 4px;
    }
    
    .bot-message .message-timestamp {
      left: 4px;
    }
    
    .chat-input-container {
      padding: 12px 16px;
      border-top: 1px solid var(--panel-border);
      background: var(--panel-accent);
      display: flex;
      gap: 10px;
    }
    
    .chat-input {
      flex: 1;
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid var(--panel-border);
      border-radius: 8px;
      padding: 10px 14px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      color: var(--text-primary);
      outline: none;
      transition: all 0.2s ease;
    }
    
    .chat-input:focus {
      border-color: var(--primary);
      box-shadow: 0 0 0 2px rgba(58, 123, 213, 0.3);
    }
    
    .chat-send {
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .chat-send:hover {
      background: var(--primary-light);
    }
    
    .chat-send:active {
      transform: scale(0.95);
    }
    
    .api-status {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 6px;
      transition: all 0.3s ease;
    }
    
    .api-status.connected {
      background: #4caf50;
      box-shadow: 0 0 8px rgba(76, 175, 80, 0.6);
    }
    
    .api-status.connecting {
      background: #ffc107;
      box-shadow: 0 0 8px rgba(255, 193, 7, 0.6);
      animation: pulse 1.5s infinite;
    }
    
    .api-status.disconnected {
      background: #9e9e9e;
    }
    
    .api-status.error {
      background: #f44336;
      box-shadow: 0 0 8px rgba(244, 67, 54, 0.6);
    }
    
    .api-status.processing {
      background: #2196f3;
      box-shadow: 0 0 8px rgba(33, 150, 243, 0.6);
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% {
        opacity: 0.6;
      }
      50% {
        opacity: 1;
      }
      100% {
        opacity: 0.6;
      }
    }
    
    .chat-toggle {
      position: fixed;
      bottom: 15px;
      right: 15px;
      width: 40px;
      height: 40px;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      transition: all 0.3s ease;
      z-index: 999;
    }
    
    .chat-toggle:hover {
      background: var(--primary-light);
      transform: scale(1.05);
    }
    
    .chat-toggle:active {
      transform: scale(0.95);
    }
  </style>
  
  <!-- Include Chat API components -->
  <script src="chatbot-component/api.js"></script>
  <script src="chatbot-component/chatbot.js"></script>
  <script src="chatbot-component/connection.js"></script>
  <script src="chatbot-component/debug.js"></script>
  <script src="chatbot-component/three-test.js"></script>
  <script src="audio-analyzer.js"></script>
  <script src="audio-integration.js"></script>
</head>
<body>
  <!-- Grid overlay for futuristic look -->
  <div class="grid-overlay"></div>

  <!-- Debug Console -->
  <div id="debugConsole"></div>

  <!-- Loading Screen -->
  <div class="loading-screen" id="loadingScreen">
    <div class="loading-spinner">
      <div class="loading-spinner-inner"></div>
    </div>
    <div class="loading-text">Initializing Quantum Simulator</div>
  </div>

  <div id="particleCanvas"></div>
  
  <button id="fullscreenBtn" class="fullscreen-button">Fullscreen</button>
  
  <!-- Stats Display -->
  <div class="stats-display">
    <div class="stat-item">
      <div class="stat-label">FPS</div>
      <div class="stat-value digital-readout" id="fps-display">60</div>
    </div>
    <div class="stat-item">
      <div class="stat-label">Particles</div>
      <div class="stat-value digital-readout" id="particle-count-display">1500</div>
    </div>
    <div class="stat-item">
      <div class="stat-label">Connections</div>
      <div class="stat-value digital-readout" id="connection-count-display">0</div>
    </div>
  </div>
  
  <!-- Shape Mode Control -->
  <div class="control-panel shape-controls">
    <h3>Shape Mode</h3>
    <div class="button-group" id="shapeModes">
      <button data-mode="free" class="active">Free</button>
      <button data-mode="sphere">Sphere</button>
      <button data-mode="ring">Ring</button>
      <button data-mode="donut">Donut</button>
      <button data-mode="toroid">Toroid</button>
      <button data-mode="entanglement">Entanglement</button>
      <button data-mode="superposition">Superposition</button>
      <button data-mode="tunneling">Tunneling</button>
      <button data-mode="harmonics">Harmonics</button>
      <button data-mode="wave">Wave</button>
    </div>
  </div>

  <!-- Color Mode Control -->
  <div class="control-panel color-controls">
    <h3>Color Mode</h3>
    <div class="button-group" id="colorModes">
      <button data-mode="default" class="active">Default</button>
      <button data-mode="spectrum">Spectrum</button>
      <button data-mode="pulse">Pulse</button>
      <button data-mode="quantum">Quantum</button>
      <button data-mode="energy">Energy</button>
      <button data-mode="harmonic">Harmonic</button>
      <button data-mode="custom">Custom</button>
    </div>
    
    <!-- Custom Color Picker (initially hidden) -->
    <div id="colorCustomizer" class="color-customizer" style="display: none; margin-top: 10px;">
      <div class="color-slider-group">
        <label>Base Color</label>
        <input type="color" id="baseColorPicker" value="#5e9eff">
      </div>
      <div class="color-slider-group">
        <label>Secondary Color</label>
        <input type="color" id="secondaryColorPicker" value="#ff4081">
      </div>
      <div class="color-slider-group">
        <label>Color Variance</label>
        <input type="range" id="colorVarianceSlider" min="0" max="1" step="0.01" value="0.3">
      </div>
    </div>
  </div>

  <!-- Settings Panel -->
  <div class="control-panel settings-panel" id="settingsPanel">
    <h3>Quantum Simulator</h3>
    
    <div class="tabs">
      <button class="tab active" data-tab="particles">Particles</button>
      <button class="tab" data-tab="interactions">Interactions</button>
      <button class="tab" data-tab="effects">Effects</button>
      <button class="tab" data-tab="audio">Audio</button>
    </div>
    
    <div id="particles-tab" class="tab-content">
      <!-- Will be populated by JS -->
    </div>
    
    <div id="interactions-tab" class="tab-content" style="display:none">
      <!-- Will be populated by JS -->
    </div>
    
    <div id="effects-tab" class="tab-content" style="display:none">
      <!-- Will be populated by JS -->
    </div>
    
    <div id="audio-tab" class="tab-content" style="display:none">
      <div class="settings-group">
        <h4>Audio Visualization</h4>
        
        <div class="audio-controls">
          <button id="micButton" class="audio-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3z"></path>
              <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
              <line x1="12" y1="19" x2="12" y2="22"></line>
            </svg>
            Use Microphone
          </button>
          
          <div class="file-input-wrapper">
            <button id="fileButton" class="audio-button">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
              </svg>
              Load Audio File
            </button>
            <input type="file" id="audioFileInput" accept="audio/*" style="display: none;">
          </div>
        </div>
        
        <h4>Harmonic Generation</h4>
        <div class="harmonic-controls">
          <div class="frequency-selector">
            <label for="baseFrequency">Base Frequency (Hz)</label>
            <select id="baseFrequency">
              <option value="55">A1 (55 Hz)</option>
              <option value="110">A2 (110 Hz)</option>
              <option value="220">A3 (220 Hz)</option>
              <option value="440" selected>A4 (440 Hz)</option>
              <option value="880">A5 (880 Hz)</option>
            </select>
          </div>
          
          <div class="harmonic-series">
            <label>Harmonic Series</label>
            <div class="harmonic-buttons">
              <button class="harmonic-preset" data-harmonics="1,2,3,4,5">Natural</button>
              <button class="harmonic-preset" data-harmonics="1,1.5,2">Perfect Fifth</button>
              <button class="harmonic-preset" data-harmonics="1,1.25,1.5,2">Major</button>
              <button class="harmonic-preset" data-harmonics="1,1.2,1.5">Minor</button>
            </div>
          </div>
          
          <button id="playButton" class="audio-button play-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polygon points="5 3 19 12 5 21 5 3"></polygon>
            </svg>
            Play
          </button>
        </div>
        
        <div class="audio-visualization">
          <canvas id="audioVisualizerCanvas" width="200" height="80"></canvas>
        </div>
      </div>
    </div>

    <div style="margin-top: 20px;">
      <button id="toggleDebug">Show Debug Console</button>
    </div>
  </div>
  
  <div class="quantum-logo">Quantum Simulator X <span class="with-ai-badge">with AI</span></div>

  <!-- Chat Interface -->
  <button id="chatBtn" class="chat-toggle">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-message-circle">
      <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>
    </svg>
  </button>
  
  <div class="chat-overlay" id="chatOverlay">
    <div class="chat-header">
      <div class="chat-title">
        <span class="api-status" title="Disconnected"></span>
        Quantum Assistant
      </div>
      <button class="chat-close" id="chatClose">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
    </div>
    <div class="chat-messages" id="chatMessages">
      <!-- Messages will be added here -->
    </div>
    <div class="chat-input-container">
      <input type="text" id="chatInput" class="chat-input" placeholder="Ask about the simulation..." />
      <button id="chatSend" class="chat-send">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="22" y1="2" x2="11" y2="13"></line>
          <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
        </svg>
      </button>
    </div>
  </div>

  <!-- Load our custom scripts as ES modules -->
  <script type="module">
    // Import Three.js
    import * as THREE from 'three';
    
    // Custom console logger that also shows in debug panel
    const debugConsole = document.getElementById('debugConsole');
    const originalConsole = {
      log: console.log,
      error: console.error,
      warn: console.warn,
      info: console.info
    };

    function addDebugMessage(message, type = 'info') {
      const msgElement = document.createElement('div');
      msgElement.classList.add('debug-message', `debug-${type}`);
      msgElement.textContent = message;
      debugConsole.appendChild(msgElement);
      debugConsole.scrollTop = debugConsole.scrollHeight;
    }

    // Override console methods
    console.log = function(...args) {
      originalConsole.log(...args);
      addDebugMessage(args.map(x => typeof x === 'object' ? JSON.stringify(x) : x).join(' '), 'info');
    };

    console.error = function(...args) {
      originalConsole.error(...args);
      addDebugMessage(args.map(x => typeof x === 'object' ? JSON.stringify(x) : x).join(' '), 'error');
    };

    console.warn = function(...args) {
      originalConsole.warn(...args);
      addDebugMessage(args.map(x => typeof x === 'object' ? JSON.stringify(x) : x).join(' '), 'warning');
    };

    // Toggle debug console
    document.getElementById('toggleDebug').addEventListener('click', () => {
      if (debugConsole.style.display === 'none') {
        debugConsole.style.display = 'block';
        document.getElementById('toggleDebug').textContent = 'Hide Debug Console';
      } else {
        debugConsole.style.display = 'none';
        document.getElementById('toggleDebug').textContent = 'Show Debug Console';
      }
    });

    // Performance monitoring
    let lastTime = 0;
    let frameCounter = 0;
    let fpsValue = 0;
    
    function updateFPS(timestamp) {
      if (!lastTime) lastTime = timestamp;
      
      const elapsed = timestamp - lastTime;
      frameCounter++;
      
      if (elapsed >= 1000) {
        fpsValue = Math.round((frameCounter * 1000) / elapsed);
        document.getElementById('fps-display').textContent = fpsValue;
        frameCounter = 0;
        lastTime = timestamp;
      }
      
      requestAnimationFrame(updateFPS);
    }
    
    requestAnimationFrame(updateFPS);

    // Log page load info
    console.log("Page loaded at " + new Date().toLocaleTimeString());
    
    // Global error handling
    window.addEventListener('error', function(e) {
      console.error('Global error:', e.message, 'at', e.filename, 'line', e.lineno);
    });

    // Main Quantum Simulation code
    document.addEventListener('DOMContentLoaded', async () => {
      // Log that DOM is loaded
      console.log("DOM fully loaded");

      // Check if THREE is available
      if (typeof THREE === 'undefined') {
        console.error("THREE.js module not properly loaded! Check your import map configuration.");
        alert("THREE.js library failed to load. Please refresh the page or check your network connection.");
        return;
      }
      
      console.log("THREE.js loaded successfully, version:", THREE.REVISION);

      // Loading screen handlers
      const loadingScreen = document.getElementById('loadingScreen');
      
      function hideLoading() {
        console.log("Hiding loading screen");
        loadingScreen.classList.add('hidden');
        setTimeout(() => {
          loadingScreen.style.display = 'none';
        }, 500);
      }
      
      // Default settings
      const settings = {
        // Particle properties
        particleCount: 3000, // Increased for more complex simulations
        particleSize: 0.3,   // Slightly smaller for better performance
        sphereRadius: 18,    // Larger radius for more space
        
        // Connections
        connectionDistance: 4.5,
        connectionOpacity: 0.4,
        maxConnections: 15000, // Increased for more detailed connections
        
        // Movement
        movementSpeed: 0.012,
        containmentForce: 0.04,
        velocityDamping: 0.96, // Less damping for more dynamic movement
        
        // Interactions
        interactionStrength: 0.15,
        interactionRadius: 15,
        
        // Quantum Physics Properties
        quantumProbability: 0.35,   // Probability of quantum events
        waveFunctionCollapse: 0.08, // Probability of wave function collapse
        uncertaintyFactor: 0.6,     // Heisenberg uncertainty effect strength
        entanglementStrength: 0.14, // Quantum entanglement strength
        entanglementDistance: 8,    // Max distance for entangled particles
        
        // Wave Properties
        waveFrequency: 0.6,
        waveAmplitude: 1.8,
        harmonicSeries: [1, 2, 3, 5, 8, 13, 21], // Fibonacci-based harmonic series
        fundamentalFrequency: 0.2,
        
        // Audio Visualization
        audioResponseFactor: 0.8,
        pulseStrength: 0.0,       // Used for beat visualization
        pulseDuration: 0.3,       // How long each pulse lasts
        frequencyBands: 12,  // Number of frequency bands for audio
        
        // Effects
        pulseFrequency: 0.5,
        pulseStrength: 0.12,
        waveAmplitude: 0.8,
        waveFrequency: 0.3,
        entanglementStrength: 0.4,
        entanglementDistance: 15,
        
        // Quantum effects
        quantumFluctuation: 0.05,
        quantumProbability: 0.3,
        toroidRadius: 12,
        toroidTubeRadius: 3.5
      };

      // Mode states
      let shapeMode = 'free';
      let colorMode = 'default';
      let activeTab = 'particles';
      let isInitializing = true;

      try {
        // Initialize Three.js
        console.log("Initializing Three.js scene");
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        // Create renderer with better performance settings
        const renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: true,
          powerPreference: "high-performance"
        });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x0a0e17); // Match our UI background color

        // Add renderer to DOM
        const container = document.getElementById('particleCanvas');
        if (!container) {
          throw new Error("Container element #particleCanvas not found!");
        }
        
        container.appendChild(renderer.domElement);
        console.log("Renderer added to DOM");

        // Particles setup
        let particleSystem;
        let connectionsLines;
        let velocities;
        let targetPositions = null;
        let originalPositions = null; // Store original positions for entanglement
        let entanglementPairs = null; // Store pairs for entanglement
        let frameSkipCounter = 0;
        let mouseX = 0;
        let mouseY = 0;
        let mouseIsMoving = false;
        let mouseMovementTimeout;
        let frameCount = 0;
        let animationId = null;
        let currentConnectionCount = 0;

        function initParticles() {
          console.log("Initializing particle system");
          try {
            // Cleanup previous system if it exists
            if (particleSystem) {
              console.log("Removing previous particle system");
              scene.remove(particleSystem);
              scene.remove(connectionsLines);
              
              particleSystem.geometry.dispose();
              particleSystem.material.dispose();
              connectionsLines.geometry.dispose();
              connectionsLines.material.dispose();
            }

            // Log particle count
            console.log(`Creating ${settings.particleCount} particles`);
            
            // Create particles
            const particleCount = settings.particleCount;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            velocities = new Float32Array(particleCount * 3);
            originalPositions = new Float32Array(particleCount * 3);
            
            // Create entanglement pairs if using that mode
            if (shapeMode === 'entanglement') {
              console.log("Creating entanglement pairs");
              entanglementPairs = new Int32Array(particleCount);
              // Create pairs of entangled particles
              for (let i = 0; i < particleCount; i += 2) {
                entanglementPairs[i] = i + 1;
                entanglementPairs[i + 1] = i;
              }
            } else {
              entanglementPairs = null;
            }

            // Initialize particle positions, colors, and velocities
            for (let i = 0; i < particleCount; i++) {
              const i3 = i * 3;
              const radius = settings.sphereRadius;
              
              // Initial random position
              const theta = Math.random() * Math.PI * 2;
              const phi = Math.acos(2 * Math.random() - 1);
              const r = radius * Math.cbrt(Math.random());
              
              positions[i3] = r * Math.sin(phi) * Math.cos(theta);
              positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
              positions[i3 + 2] = r * Math.cos(phi);
              
              // Store original positions for reference
              originalPositions[i3] = positions[i3];
              originalPositions[i3 + 1] = positions[i3 + 1];
              originalPositions[i3 + 2] = positions[i3 + 2];
              
              // Default refined color scheme - more subtle blue tones
              colors[i3] = 0.15 + (Math.random() * 0.05);     // reduced red
              colors[i3 + 1] = 0.4 + (Math.random() * 0.15);  // enhanced green
              colors[i3 + 2] = 0.8 + (Math.random() * 0.2);   // full blue
              
              // Initialize velocities
              velocities[i3] = (Math.random() - 0.5) * 0.01;
              velocities[i3 + 1] = (Math.random() - 0.5) * 0.01;
              velocities[i3 + 2] = (Math.random() - 0.5) * 0.01;
            }
            
            // Create BufferAttributes for the geometry
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Create particle material with vertex colors & custom point texture
            const material = new THREE.PointsMaterial({
              size: settings.particleSize,
              vertexColors: true,
              transparent: true,
              opacity: 0.9,
              blending: THREE.AdditiveBlending,
              sizeAttenuation: true,
              alphaTest: 0.1
            });
            
            // Create the particle system
            particleSystem = new THREE.Points(particles, material);
            scene.add(particleSystem);
            console.log("Particle system created and added to scene");
            
            // Create connections material with improved color
            const connectionsMaterial = new THREE.LineBasicMaterial({
              color: 0x5e9eff, // Refined brighter blue
              transparent: true,
              opacity: settings.connectionOpacity,
              blending: THREE.AdditiveBlending
            });
            
            // Create connections geometry - start with empty position buffer
            const connectionsGeometry = new THREE.BufferGeometry();
            const emptyPositions = new Float32Array(6); // Just a single segment to initialize
            connectionsGeometry.setAttribute('position', new THREE.BufferAttribute(emptyPositions, 3));
            
            connectionsLines = new THREE.LineSegments(connectionsGeometry, connectionsMaterial);
            scene.add(connectionsLines);
            console.log("Connection lines created and added to scene");
            
            // Update the particle counter display
            document.getElementById('particle-count-display').textContent = settings.particleCount;
            
            isInitializing = false;
            console.log("Particle initialization complete");
            
            // Hide loading screen once first init is complete
            hideLoading();
          } catch (error) {
            console.error("Error in initParticles:", error.message);
            hideLoading();
            alert("Error initializing particles: " + error.message);
          }
        }

        // Shape functions
        function createSphere() {
          console.log("Creating sphere shape");
          const particleCount = settings.particleCount;
          const targetPositions = new Float32Array(particleCount * 3);
          
          for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            const phi = Math.acos(-1 + (2 * i) / particleCount);
            const theta = Math.sqrt(particleCount * Math.PI) * phi;
            const radius = settings.sphereRadius;
            
            targetPositions[i3] = radius * Math.cos(theta) * Math.sin(phi);
            targetPositions[i3 + 1] = radius * Math.sin(theta) * Math.sin(phi);
            targetPositions[i3 + 2] = radius * Math.cos(phi);
          }
          
          return targetPositions;
        }
        
        function createRing() {
          console.log("Creating ring shape");
          const particleCount = settings.particleCount;
          const targetPositions = new Float32Array(particleCount * 3);
          const radius = settings.sphereRadius;
          
          for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            const angle = (i / particleCount) * Math.PI * 2;
            
            targetPositions[i3] = radius * Math.cos(angle);
            targetPositions[i3 + 1] = radius * Math.sin(angle);
            targetPositions[i3 + 2] = (Math.random() - 0.5) * 2; // Slight z variation for more interesting look
          }
          
          return targetPositions;
        }
        
        function createDonut() {
          console.log("Creating donut shape");
          const particleCount = settings.particleCount;
          const targetPositions = new Float32Array(particleCount * 3);
          const torusRadius = 10;
          const tubeRadius = 3;
          
          for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            const u = (i / particleCount) * Math.PI * 2;
            const v = (Math.floor(i / 20) / Math.floor(particleCount / 20)) * Math.PI * 2;
            
            targetPositions[i3] = (torusRadius + tubeRadius * Math.cos(v)) * Math.cos(u);
            targetPositions[i3 + 1] = (torusRadius + tubeRadius * Math.cos(v)) * Math.sin(u);
            targetPositions[i3 + 2] = tubeRadius * Math.sin(v);
          }
          
          return targetPositions;
        }
        
        function createToroid() {
          console.log("Creating toroid shape");
          const particleCount = settings.particleCount;
          const targetPositions = new Float32Array(particleCount * 3);
          const torusRadius = settings.toroidRadius;
          const tubeRadius = settings.toroidTubeRadius;
          
          for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            // Use more precise distribution
            const u = (i / particleCount) * Math.PI * 2;
            const v = (i % 100 / 100) * Math.PI * 2;
            
            targetPositions[i3] = (torusRadius + tubeRadius * Math.cos(v)) * Math.cos(u);
            targetPositions[i3 + 1] = (torusRadius + tubeRadius * Math.cos(v)) * Math.sin(u);
            targetPositions[i3 + 2] = tubeRadius * Math.sin(v);
          }
          
          return targetPositions;
        }
        
        function createWave() {
          console.log("Creating wave shape");
          const particleCount = settings.particleCount;
          const targetPositions = new Float32Array(particleCount * 3);
          const radius = settings.sphereRadius;
          
          // Create a wave pattern along a plane
          for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            
            // Create grid-like distribution
            const gridSize = Math.ceil(Math.sqrt(particleCount));
            const x = (i % gridSize) - gridSize / 2;
            const z = Math.floor(i / gridSize) - gridSize / 2;
            
            // Normalize to radius
            const normalizedX = (x / (gridSize / 2)) * radius;
            const normalizedZ = (z / (gridSize / 2)) * radius;
            
            targetPositions[i3] = normalizedX;
            targetPositions[i3 + 1] = 0; // Will be animated with wave
            targetPositions[i3 + 2] = normalizedZ;
          }
          
          return targetPositions;
        }
        
        function createEntanglement() {
          console.log("Creating entanglement shape");
          const particleCount = settings.particleCount;
          const targetPositions = new Float32Array(particleCount * 3);
          const radius = settings.sphereRadius;
          
          // Initialize particles in pairs across the sphere
          for (let i = 0; i < particleCount; i += 2) {
            const i3 = i * 3;
            const j3 = (i + 1) * 3;
            
            // Create a random point on the sphere
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);
            
            // First particle
            targetPositions[i3] = x;
            targetPositions[i3 + 1] = y;
            targetPositions[i3 + 2] = z;
            
            // Second particle (180 degrees opposite)
            targetPositions[j3] = -x;
            targetPositions[j3 + 1] = -y;
            targetPositions[j3 + 2] = -z;
          }
          
          return targetPositions;
        }
        
        function createHarmonics() {
          console.log("Creating harmonics shape with series:", settings.harmonicSeries);
          const particleCount = settings.particleCount;
          const targetPositions = new Float32Array(particleCount * 3);
          const radius = settings.sphereRadius;
          const amplitude = settings.waveAmplitude || 1.8;
          const harmonics = settings.harmonicSeries || [1, 2, 3, 5, 8, 13, 21];
          const fundFreq = settings.fundamentalFrequency || 0.2;
          
          // Number of layers based on harmonics length
          const layerCount = harmonics.length;
          const particlesPerLayer = Math.floor(particleCount / layerCount);
          
          // For each harmonic, create a layer of particles
          for (let h = 0; h < layerCount; h++) {
            const harmonic = harmonics[h];
            const layerFrequency = fundFreq * harmonic;
            const layerOffset = (h / layerCount) * Math.PI * 2;
            const layerRadius = radius * (0.3 + 0.7 * (h / layerCount));
            
            for (let i = 0; i < particlesPerLayer; i++) {
              const particleIndex = h * particlesPerLayer + i;
              if (particleIndex >= particleCount) break;
              
              // Position in the ring
              const angle = (i / particlesPerLayer) * Math.PI * 2;
              const ringX = layerRadius * Math.cos(angle);
              const ringY = layerRadius * Math.sin(angle);
              
              // Wave height based on harmonics
              const wavePhase = layerOffset + angle * layerFrequency;
              const waveHeight = amplitude * Math.sin(wavePhase);
              
              // Set particle position - arrange in expanding rings with wave pattern
              const i3 = particleIndex * 3;
              targetPositions[i3] = ringX;
              targetPositions[i3 + 1] = waveHeight;
              targetPositions[i3 + 2] = ringY;
            }
          }
          
          // Handle any remaining particles
          const remaining = particleCount - (particlesPerLayer * layerCount);
          if (remaining > 0) {
            for (let i = 0; i < remaining; i++) {
              const particleIndex = particlesPerLayer * layerCount + i;
              const i3 = particleIndex * 3;
              
              // Create extra particles in center sphere
              const theta = Math.random() * Math.PI * 2;
              const phi = Math.acos(2 * Math.random() - 1);
              const r = radius * 0.2 * Math.random();
              
              targetPositions[i3] = r * Math.sin(phi) * Math.cos(theta);
              targetPositions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
              targetPositions[i3 + 2] = r * Math.cos(phi);
            }
          }
          
          return targetPositions;
        }

        function updateTargetPositions() {
          console.log(`Updating target positions for shape mode: ${shapeMode}`);
          switch (shapeMode) {
            case 'sphere':
              targetPositions = createSphere();
              break;
            case 'ring':
              targetPositions = createRing();
              break;
            case 'donut':
              targetPositions = createDonut();
              break;
            case 'toroid':
              targetPositions = createToroid();
              break;
            case 'wave':
              targetPositions = createWave();
              break;
            case 'harmonics':
              targetPositions = createHarmonics();
              break;
            case 'entanglement':
              // Reset entanglement pairs
              entanglementPairs = new Int32Array(settings.particleCount);
              for (let i = 0; i < settings.particleCount; i += 2) {
                entanglementPairs[i] = i + 1;
                entanglementPairs[i + 1] = i;
              }
              targetPositions = createEntanglement();
              break;
            default:
              targetPositions = null;
              console.log("Free mode activated, no target positions");
              break;
          }
        }

        // Animation loop
        function animate() {
          try {
            animationId = requestAnimationFrame(animate);
            frameCount++;
            
            if (!particleSystem || !particleSystem.geometry || !particleSystem.geometry.attributes || 
                !particleSystem.geometry.attributes.position) {
              console.warn("Animation skipped: particle system not properly initialized");
              return; // Skip if not properly initialized
            }
            
            const positions = particleSystem.geometry.attributes.position.array;
            const colors = particleSystem.geometry.attributes.color.array;
            const particleCount = settings.particleCount;
            
            // Update target positions if mode changed
            if (shapeMode !== 'free' && !targetPositions) {
              updateTargetPositions();
            } else if (shapeMode === 'free' && targetPositions) {
              targetPositions = null;
            }
            
            // Simulate audio-reactive pulse effect
            const time = Date.now() * 0.001;
            const pulse = (Math.sin(time * settings.pulseFrequency) + 1) / 2;
            const bassPulse = (Math.sin(time * 0.75) + 1) / 2;
            const midPulse = (Math.sin(time * 1.5) + 1) / 2;
            const treblePulse = (Math.sin(time * 2.5) + 1) / 2;
            
            // Update particles with enhanced quantum physics
            for (let i = 0; i < particleCount; i++) {
              const i3 = i * 3;
              
              // Apply Heisenberg uncertainty principle
              // Position and momentum cannot be precisely determined simultaneously
              if (Math.random() < settings.uncertaintyFactor * 0.01) {
                const uncertaintyEffect = (Math.random() - 0.5) * 0.08;
                positions[i3] += uncertaintyEffect;
                positions[i3 + 1] += uncertaintyEffect;
                positions[i3 + 2] += uncertaintyEffect;
                
                // Inverse effect on velocity (as position certainty increases, velocity certainty decreases)
                velocities[i3] -= uncertaintyEffect * 10;
                velocities[i3 + 1] -= uncertaintyEffect * 10;
                velocities[i3 + 2] -= uncertaintyEffect * 10;
              }
              
              if (targetPositions && shapeMode !== 'free') {
                // Handle special modes first
                if (shapeMode === 'wave') {
                  const waveTime = time * settings.waveFrequency;
                  const x = targetPositions[i3];
                  const z = targetPositions[i3 + 2];
                  const distance = Math.sqrt(x * x + z * z);
                  
                  // Create a ripple wave effect
                  const ripple = Math.sin(distance - waveTime * 3) * settings.waveAmplitude;
                  
                  // Move toward target x and z, but use wave function for y
                  const tx = targetPositions[i3] - positions[i3];
                  const ty = ripple - positions[i3 + 1];
                  const tz = targetPositions[i3 + 2] - positions[i3 + 2];
                  
                  velocities[i3] += tx * settings.movementSpeed * 5;
                  velocities[i3 + 1] += ty * settings.movementSpeed * 5;
                  velocities[i3 + 2] += tz * settings.movementSpeed * 5;
                } 
                else if (shapeMode === 'entanglement' && entanglementPairs) {
                  // Quantum entanglement effect
                  // First handle normal movement towards target
                  const tx = targetPositions[i3] - positions[i3];
                  const ty = targetPositions[i3 + 1] - positions[i3 + 1];
                  const tz = targetPositions[i3 + 2] - positions[i3 + 2];
                  
                  velocities[i3] += tx * settings.movementSpeed * 3;
                  velocities[i3 + 1] += ty * settings.movementSpeed * 3;
                  velocities[i3 + 2] += tz * settings.movementSpeed * 3;
                  
                  // Then handle entanglement - paired particles affect each other
                  const pairedIndex = entanglementPairs[i];
                  
                  if (pairedIndex !== undefined && pairedIndex < particleCount) {
                    const j3 = pairedIndex * 3;
                    // Calculate distance between pairs
                    const dx = positions[i3] - positions[j3];
                    const dy = positions[i3 + 1] - positions[j3 + 1];
                    const dz = positions[i3 + 2] - positions[j3 + 2];
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    
                    if (dist > settings.entanglementDistance) {
                      // If too far, add attraction
                      const force = settings.entanglementStrength * (dist - settings.entanglementDistance) / dist;
                      velocities[i3] -= dx * force * 0.5;
                      velocities[i3 + 1] -= dy * force * 0.5;
                      velocities[i3 + 2] -= dz * force * 0.5;
                    }
                    
                    // Add mirrored movements - what affects one affects the other
                    if (frameCount % 3 === 0 && Math.random() < settings.quantumProbability) {
                      velocities[j3] = -velocities[i3] * 0.8;
                      velocities[j3 + 1] = -velocities[i3 + 1] * 0.8;
                      velocities[j3 + 2] = -velocities[i3 + 2] * 0.8;
                    }
                  }
                }
                else if (shapeMode === 'superposition') {
                  // Quantum superposition - particles exist in multiple states simultaneously
                  // We'll visualize this with oscillation between two positions
                  
                  // Create an oscillation between primary and secondary positions
                  const oscillationFactor = (Math.sin(time * 2 + i * 0.1) + 1) / 2;
                  
                  // Primary position - from target
                  const primaryX = targetPositions[i3];
                  const primaryY = targetPositions[i3 + 1];
                  const primaryZ = targetPositions[i3 + 2];
                  
                  // Secondary position - mirrored on one axis for superposition visualization
                  const secondaryX = -primaryX * 0.7;
                  const secondaryY = primaryY * 0.8;
                  const secondaryZ = primaryZ * 0.7;
                  
                  // Blend between the two states based on oscillation
                  const superpositionX = primaryX * oscillationFactor + secondaryX * (1 - oscillationFactor);
                  const superpositionY = primaryY * oscillationFactor + secondaryY * (1 - oscillationFactor);
                  const superpositionZ = primaryZ * oscillationFactor + secondaryZ * (1 - oscillationFactor);
                  
                  // Calculate velocity toward the superposition state
                  const tx = superpositionX - positions[i3];
                  const ty = superpositionY - positions[i3 + 1];
                  const tz = superpositionZ - positions[i3 + 2];
                  
                  // Apply force toward superposition state
                  velocities[i3] += tx * settings.movementSpeed * 3;
                  velocities[i3 + 1] += ty * settings.movementSpeed * 3;
                  velocities[i3 + 2] += tz * settings.movementSpeed * 3;
                }
                else if (shapeMode === 'harmonics') {
                  // Audio-reactive harmonic patterns
                  // Target positions already contain the base harmonic structure
                  
                  // Get the base positions from target
                  const tx = targetPositions[i3];
                  const ty = targetPositions[i3 + 1];
                  const tz = targetPositions[i3 + 2];
                  
                  // Calculate distance from center for frequency-based modulation
                  const distFromCenter = Math.sqrt(tx*tx + tz*tz);
                  
                  // Apply audio-reactive modulations if pulseStrength is set (from audio analyzer)
                  let audioReactiveY = ty;
                  if (settings.pulseStrength > 0) {
                    // Add pulse effect for beat visualization
                    const pulseFactor = settings.pulseStrength * Math.exp(-frameCount * 0.05);
                    audioReactiveY += pulseFactor * Math.sin(distFromCenter * 0.5) * 2;
                    
                    // Gradually reduce pulse strength
                    settings.pulseStrength *= 0.95;
                    if (settings.pulseStrength < 0.01) settings.pulseStrength = 0;
                  }
                  
                  // Apply movement toward the audio-reactive position
                  const dx = tx - positions[i3];
                  const dy = audioReactiveY - positions[i3 + 1];
                  const dz = tz - positions[i3 + 2];
                  
                  velocities[i3] += dx * settings.movementSpeed * 4;
                  velocities[i3 + 1] += dy * settings.movementSpeed * 4;
                  velocities[i3 + 2] += dz * settings.movementSpeed * 4;
                  
                  // Randomly collapse wave function for some particles
                  if (Math.random() < settings.waveFunctionCollapse) {
                    // Particle "decides" to be in one state or the other
                    const collapseState = Math.random() > 0.5 ? 1 : 0;
                    velocities[i3] += (collapseState ? primaryX : secondaryX - positions[i3]) * 0.1;
                    velocities[i3 + 1] += (collapseState ? primaryY : secondaryY - positions[i3 + 1]) * 0.1;
                    velocities[i3 + 2] += (collapseState ? primaryZ : secondaryZ - positions[i3 + 2]) * 0.1;
                  }
                }
                else if (shapeMode === 'tunneling') {
                  // Quantum tunneling - particles can pass through energy barriers
                  // We'll visualize this with particles passing through invisible barriers
                  
                  const tx = targetPositions[i3] - positions[i3];
                  const ty = targetPositions[i3 + 1] - positions[i3 + 1];
                  const tz = targetPositions[i3 + 2] - positions[i3 + 2];
                  
                  // Normal movement toward target
                  velocities[i3] += tx * settings.movementSpeed * 2;
                  velocities[i3 + 1] += ty * settings.movementSpeed * 2;
                  velocities[i3 + 2] += tz * settings.movementSpeed * 2;
                  
                  // Create barriers that particles typically can't pass
                  const barrierWidth = 1.2;
                  const barrierCount = 3;
                  
                  for (let b = 0; b < barrierCount; b++) {
                    const barrierPos = (b - barrierCount/2) * 10;
                    const distToBarrier = Math.abs(positions[i3] - barrierPos);
                    
                    if (distToBarrier < barrierWidth) {
                      // Particle is at barrier - apply force to push it back
                      const repelForce = 0.05;
                      const direction = positions[i3] < barrierPos ? -1 : 1;
                      
                      // Regular particles are repelled by the barrier
                      velocities[i3] += direction * repelForce;
                      
                      // Quantum tunneling - random chance for particles to tunnel through barrier
                      if (Math.random() < settings.quantumProbability * 0.1) {
                        // Tunneling probability decreases with barrier width
                        velocities[i3] -= direction * repelForce * 2; // Cancel the repel force and add extra impulse
                        
                        // Visual effect for tunneling
                        colors[i3] = 1.0;  // R
                        colors[i3 + 1] = 0.3; // G
                        colors[i3 + 2] = 0.8; // B
                      }
                    }
                  }
                }
                else if (shapeMode === 'toroid') {
                  // Custom toroid animation with flowing movement
                  const tx = targetPositions[i3] - positions[i3];
                  const ty = targetPositions[i3 + 1] - positions[i3 + 1];
                  const tz = targetPositions[i3 + 2] - positions[i3 + 2];
                  
                  // Use movement speed for shape transitions with slight variation
                  const transitionSpeed = settings.movementSpeed * (4 + Math.sin(i * 0.1) * 0.5);
                  velocities[i3] += tx * transitionSpeed;
                  velocities[i3 + 1] += ty * transitionSpeed;
                  velocities[i3 + 2] += tz * transitionSpeed;
                  
                  // Add flow around the toroid
                  const flowSpeed = 0.005;
                  const idx = Math.floor(i / 3) % 100;
                  const angle = (idx / 100) * Math.PI * 2;
                  
                  // Add tangential velocity to create flow
                  velocities[i3] += Math.cos(angle + Math.PI/2) * flowSpeed;
                  velocities[i3 + 1] += Math.sin(angle + Math.PI/2) * flowSpeed;
                }
                else {
                  // Standard shape movement
                  const tx = targetPositions[i3] - positions[i3];
                  const ty = targetPositions[i3 + 1] - positions[i3 + 1];
                  const tz = targetPositions[i3 + 2] - positions[i3 + 2];
                  
                  // Use movement speed for shape transitions
                  const transitionSpeed = settings.movementSpeed * 5;
                  velocities[i3] += tx * transitionSpeed;
                  velocities[i3 + 1] += ty * transitionSpeed;
                  velocities[i3 + 2] += tz * transitionSpeed;
                }
                
                // Add quantum fluctuations - random micro-movements to all particles
                if (Math.random() < 0.3) {
                  velocities[i3] += (Math.random() - 0.5) * settings.quantumFluctuation;
                  velocities[i3 + 1] += (Math.random() - 0.5) * settings.quantumFluctuation;
                  velocities[i3 + 2] += (Math.random() - 0.5) * settings.quantumFluctuation;
                }
              } else {
                // Natural movement for free mode
                velocities[i3] += Math.sin(time + i) * settings.movementSpeed;
                velocities[i3 + 1] += Math.cos(time + i) * settings.movementSpeed;
                velocities[i3 + 2] += Math.sin(time * 1.1 + i) * settings.movementSpeed;
                
                // Pulsing effect
                const particleGroup = i % 3;
                let pulseInfluence = 0;
                
                switch (particleGroup) {
                  case 0: pulseInfluence = bassPulse; break;
                  case 1: pulseInfluence = midPulse; break;
                  case 2: pulseInfluence = treblePulse; break;
                }
                
                // Add pulsing effect
                const pulseDirection = new THREE.Vector3(
                  positions[i3], 
                  positions[i3 + 1], 
                  positions[i3 + 2]
                ).normalize();
                
                velocities[i3] += pulseDirection.x * pulseInfluence * settings.pulseStrength;
                velocities[i3 + 1] += pulseDirection.y * pulseInfluence * settings.pulseStrength;
                velocities[i3 + 2] += pulseDirection.z * pulseInfluence * settings.pulseStrength;
              }
              
              // Mouse interaction - always apply in all modes if mouse is moving
              if (mouseIsMoving) {
                const dx = positions[i3] - mouseX * 20;
                const dy = positions[i3 + 1] - mouseY * 20;
                const dz = positions[i3 + 2];
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                
                if (dist < settings.interactionRadius) {
                  const force = settings.interactionStrength * (1 - dist / settings.interactionRadius);
                  velocities[i3] -= dx * force;
                  velocities[i3 + 1] -= dy * force;
                }
              }
              
              // Containment for all modes
              const radius = Math.sqrt(
                positions[i3] * positions[i3] +
                positions[i3 + 1] * positions[i3 + 1] +
                positions[i3 + 2] * positions[i3 + 2]
              );
              
              if (radius > settings.sphereRadius) {
                const force = settings.containmentForce * (radius - settings.sphereRadius);
                velocities[i3] -= positions[i3] * force / radius;
                velocities[i3 + 1] -= positions[i3 + 1] * force / radius;
                velocities[i3 + 2] -= positions[i3 + 2] * force / radius;
              }
              
              // Apply damping
              velocities[i3] *= settings.velocityDamping;
              velocities[i3 + 1] *= settings.velocityDamping;
              velocities[i3 + 2] *= settings.velocityDamping;
              
              // Update positions
              positions[i3] += velocities[i3];
              positions[i3 + 1] += velocities[i3 + 1];
              positions[i3 + 2] += velocities[i3 + 2];
              
              // Special mode: Harmonic Resonance Visualization
              if (shapeMode === 'harmonics') {
                // Calculate particle's base frequency based on its index
                const particleGroup = Math.floor(i / (particleCount / settings.harmonicSeries.length));
                const harmonic = settings.harmonicSeries[particleGroup % settings.harmonicSeries.length];
                
                // Fundamental frequency * harmonic number = specific frequency for this particle
                const frequency = settings.fundamentalFrequency * harmonic;
                
                // Calculate amplitude based on the harmonic (higher harmonics generally have lower amplitude)
                const amplitude = settings.waveAmplitude / Math.sqrt(harmonic);
                
                // Apply harmonic motion (similar to a standing wave)
                const oscillation = Math.sin(time * frequency * Math.PI * 2 + positions[i3] * 0.1) * amplitude;
                
                // Apply to y position for visualization
                positions[i3 + 1] = oscillation;
                
                // Reset y velocity to follow the oscillation
                velocities[i3 + 1] = 0;
                
                // Color based on frequency - create a spectrum effect
                const hue = (harmonic % 7) / 7; // Normalized between 0-1
                
                // Convert HSL to RGB (simplified conversion)
                let r, g, b;
                
                if (hue < 1/6) {
                  r = 1; g = hue * 6; b = 0;
                } else if (hue < 2/6) {
                  r = (2/6 - hue) * 6; g = 1; b = 0;
                } else if (hue < 3/6) {
                  r = 0; g = 1; b = (hue - 2/6) * 6;
                } else if (hue < 4/6) {
                  r = 0; g = (4/6 - hue) * 6; b = 1;
                } else if (hue < 5/6) {
                  r = (hue - 4/6) * 6; b = 1; g = 0;
                } else {
                  r = 1; g = 0; b = (6/6 - hue) * 6;
                }
                
                // Apply colors
                colors[i3] = r;
                colors[i3 + 1] = g;
                colors[i3 + 2] = b;
              }
              
              // Update colors based on mode
              if (colorMode === 'spectrum') {
                // Map position to color spectrum
                const height = (positions[i3 + 1] / settings.sphereRadius + 1) / 2; // 0-1 range
                
                // Enhanced spectral coloring with more vibrant tones
                if (height < 0.2) {
                  // Deep blue to cyan
                  colors[i3] = 0.05;
                  colors[i3 + 1] = height * 4;
                  colors[i3 + 2] = 0.9;
                } else if (height < 0.4) {
                  // Cyan to green
                  colors[i3] = 0;
                  colors[i3 + 1] = 0.8;
                  colors[i3 + 2] = 1.0 - (height - 0.2) * 5;
                } else if (height < 0.6) {
                  // Green to yellow
                  colors[i3] = (height - 0.4) * 5;
                  colors[i3 + 1] = 0.9;
                  colors[i3 + 2] = 0;
                } else if (height < 0.8) {
                  // Yellow to magenta
                  colors[i3] = 0.9;
                  colors[i3 + 1] = 0.9 - (height - 0.6) * 4.5;
                  colors[i3 + 2] = (height - 0.6) * 4.5;
                } else {
                  // Magenta to deep purple
                  colors[i3] = 0.9 - (height - 0.8) * 3;
                  colors[i3 + 1] = 0;
                  colors[i3 + 2] = 0.9;
                }
              } else if (colorMode === 'pulse') {
                // Enhanced pulse-based colors for more dynamic visuals
                const particleGroup = i % 3;
                
                switch (particleGroup) {
                  case 0: // Bass (deeper red)
                    colors[i3] = 0.7 + bassPulse * 0.3;
                    colors[i3 + 1] = 0.05 + bassPulse * 0.2;
                    colors[i3 + 2] = 0.1 + bassPulse * 0.1;
                    break;
                  case 1: // Mid (teal/cyan)
                    colors[i3] = 0.05 + midPulse * 0.1;
                    colors[i3 + 1] = 0.6 + midPulse * 0.4;
                    colors[i3 + 2] = 0.6 + midPulse * 0.4;
                    break;
                  case 2: // Treble (electric blue)
                    colors[i3] = 0.05 + treblePulse * 0.1;
                    colors[i3 + 1] = 0.2 + treblePulse * 0.3;
                    colors[i3 + 2] = 0.7 + treblePulse * 0.3;
                    break;
                }
              } else if (colorMode === 'harmonic' || (shapeMode === 'harmonics' && colorMode === 'auto')) {
                // Special coloring for harmonic visualization - based on frequency bands
                // Calculate which harmonic layer this particle belongs to
                const harmonics = settings.harmonicSeries || [1, 2, 3, 5, 8, 13];
                const layerCount = harmonics.length;
                const particlesPerLayer = Math.floor(settings.particleCount / layerCount);
                const harmonicIndex = Math.floor(i / particlesPerLayer);
                
                if (harmonicIndex < layerCount) {
                  // Color based on harmonic frequency
                  const harmonic = harmonics[harmonicIndex];
                  const normalizedHarmonic = (harmonic - harmonics[0]) / 
                                            (harmonics[layerCount - 1] - harmonics[0] || 1);
                  
                  // Golden ratio coloring - creates aesthetically pleasing color progression
                  const hue = (normalizedHarmonic * 0.618033988749895) % 1.0;
                  
                  // Convert HSV to RGB
                  const h = hue * 6.0;
                  const c = 1.0;
                  const x = c * (1.0 - Math.abs((h % 2.0) - 1.0));
                  
                  let r, g, b;
                  if (h < 1) { r = c; g = x; b = 0; }
                  else if (h < 2) { r = x; g = c; b = 0; }
                  else if (h < 3) { r = 0; g = c; b = x; }
                  else if (h < 4) { r = 0; g = x; b = c; }
                  else if (h < 5) { r = x; g = 0; b = c; }
                  else { r = c; g = 0; b = x; }
                  
                  // Apply pulse effect if active
                  const pulseFactor = settings.pulseStrength > 0 ? settings.pulseStrength : pulse * 0.3;
                  
                  colors[i3] = r * (0.7 + pulseFactor * 0.3);
                  colors[i3 + 1] = g * (0.7 + pulseFactor * 0.3);
                  colors[i3 + 2] = b * (0.7 + pulseFactor * 0.3);
                } else {
                  // Central particles get a bright white/silver color
                  colors[i3] = 0.9 + pulse * 0.1;
                  colors[i3 + 1] = 0.9 + pulse * 0.1;
                  colors[i3 + 2] = 0.9 + pulse * 0.1;
                }
              } else if (colorMode === 'quantum') {
                // Enhanced quantum-style colors with energy state visualization
                const radius = Math.sqrt(
                  positions[i3] * positions[i3] +
                  positions[i3 + 1] * positions[i3 + 1] +
                  positions[i3 + 2] * positions[i3 + 2]
                );
                
                // Normalize radius to 0-1
                const normalizedRadius = Math.min(radius / settings.sphereRadius, 1);
                
                // Create "energy level" color mapping with more vibrant colors
                if (normalizedRadius < 0.2) {
                  // Innermost shell - bright cyan/white core
                  colors[i3] = 0.3 + pulse * 0.3;
                  colors[i3 + 1] = 0.7 + pulse * 0.3;
                  colors[i3 + 2] = 1.0;
                } else if (normalizedRadius < 0.4) {
                  // Second shell - bright electric blue
                  colors[i3] = 0.05 + pulse * 0.1;
                  colors[i3 + 1] = 0.5 + pulse * 0.3;
                  colors[i3 + 2] = 1.0;
                } else if (normalizedRadius < 0.6) {
                  // Third shell - deeper cobalt blue
                  colors[i3] = 0.1;
                  colors[i3 + 1] = 0.3 + pulse * 0.2;
                  colors[i3 + 2] = 0.9 - pulse * 0.1;
                } else if (normalizedRadius < 0.8) {
                  // Fourth shell - indigo to violet
                  colors[i3] = 0.2 + pulse * 0.1;
                  colors[i3 + 1] = 0.0;
                  colors[i3 + 2] = 0.7 - pulse * 0.2;
                } else {
                  // Outer shell - deep violet edges
                  colors[i3] = 0.15;
                  colors[i3 + 1] = 0.0;
                  colors[i3 + 2] = 0.4 - pulse * 0.1;
                }
                
                // Add slight variance per particle for more natural look
                const variance = (i % 10) / 10 * 0.15;
                colors[i3] = Math.min(1, colors[i3] + variance);
                colors[i3 + 1] = Math.min(1, colors[i3 + 1] + variance * 0.5);
              } else if (colorMode === 'energy') {
                // Energy level visualization
                // Calculate "energy" based on velocity (kinetic energy is proportional to velocity squared)
                const velocitySquared = 
                  velocities[i3] * velocities[i3] + 
                  velocities[i3 + 1] * velocities[i3 + 1] + 
                  velocities[i3 + 2] * velocities[i3 + 2];
                
                const energy = Math.min(velocitySquared * 50, 1); // Normalize to 0-1 range
                
                // Higher energy = hotter color (blue → cyan → green → yellow → red → white)
                if (energy < 0.2) {
                  // Low energy - blue to cyan
                  colors[i3] = 0; // R
                  colors[i3 + 1] = energy * 5; // G
                  colors[i3 + 2] = 1; // B
                } else if (energy < 0.4) {
                  // Medium-low energy - cyan to green
                  colors[i3] = 0; // R
                  colors[i3 + 1] = 1; // G
                  colors[i3 + 2] = 1 - (energy - 0.2) * 5; // B
                } else if (energy < 0.6) {
                  // Medium energy - green to yellow
                  colors[i3] = (energy - 0.4) * 5; // R
                  colors[i3 + 1] = 1; // G
                  colors[i3 + 2] = 0; // B
                } else if (energy < 0.8) {
                  // Medium-high energy - yellow to red
                  colors[i3] = 1; // R
                  colors[i3 + 1] = 1 - (energy - 0.6) * 5; // G
                  colors[i3 + 2] = 0; // B
                } else {
                  // High energy - red to white
                  colors[i3] = 1; // R
                  colors[i3 + 1] = (energy - 0.8) * 5; // G
                  colors[i3 + 2] = (energy - 0.8) * 5; // B
                }
              } else if (colorMode === 'harmonic') {
                // Harmonic resonance visualization - colors based on harmonic frequency
                // Calculate harmonic frequency based on particle position
                const distance = Math.sqrt(
                  positions[i3] * positions[i3] + 
                  positions[i3 + 2] * positions[i3 + 2]
                );
                
                // Create harmonic bands
                const harmonicIndex = Math.floor(distance * 2) % settings.harmonicSeries.length;
                const harmonic = settings.harmonicSeries[harmonicIndex];
                
                // Normalize harmonic to 0-1 for hue calculation
                const hue = (harmonic % 7) / 7;
                
                // Convert HSL to RGB (simplified conversion)
                let r, g, b;
                
                if (hue < 1/6) {
                  r = 1; g = hue * 6; b = 0;
                } else if (hue < 2/6) {
                  r = (2/6 - hue) * 6; g = 1; b = 0;
                } else if (hue < 3/6) {
                  r = 0; g = 1; b = (hue - 2/6) * 6;
                } else if (hue < 4/6) {
                  r = 0; g = (4/6 - hue) * 6; b = 1;
                } else if (hue < 5/6) {
                  r = (hue - 4/6) * 6; b = 1; g = 0;
                } else {
                  r = 1; g = 0; b = (6/6 - hue) * 6;
                }
                
                // Apply colors
                colors[i3] = r * (0.7 + pulse * 0.3);
                colors[i3 + 1] = g * (0.7 + pulse * 0.3);
                colors[i3 + 2] = b * (0.7 + pulse * 0.3);
              } else if (colorMode === 'custom' && settings.customColors) {
                // Custom user-defined colors with interpolation
                // Get base and secondary colors from settings
                const base = settings.customColors.baseColor;
                const secondary = settings.customColors.secondaryColor;
                const variance = settings.customColors.variance;
                
                // Create a blend factor based on position and time
                const blendFactor = (Math.sin(time + positions[i3] * 0.1 + positions[i3 + 2] * 0.1) + 1) / 2;
                
                // Add some randomness based on variance
                const randomFactor = Math.random() * variance;
                
                // Interpolate between base and secondary colors
                colors[i3] = base.r * (1 - blendFactor) + secondary.r * blendFactor + randomFactor - variance/2;
                colors[i3 + 1] = base.g * (1 - blendFactor) + secondary.g * blendFactor + randomFactor - variance/2;
                colors[i3 + 2] = base.b * (1 - blendFactor) + secondary.b * blendFactor + randomFactor - variance/2;
                
                // Clamp RGB values to valid range (0-1)
                colors[i3] = Math.max(0, Math.min(1, colors[i3]));
                colors[i3 + 1] = Math.max(0, Math.min(1, colors[i3 + 1]));
                colors[i3 + 2] = Math.max(0, Math.min(1, colors[i3 + 2]));
              } else {
                // Enhanced default color scheme with blues and subtle variations
                // Use sin wave of positions for more dynamic coloring
                const positionFactor = Math.sin(positions[i3] * 0.1 + positions[i3 + 1] * 0.1 + time * 0.2) * 0.5 + 0.5;
                
                colors[i3] = 0.15 + positionFactor * 0.1;               // Subtle blue with hints of other colors
                colors[i3 + 1] = 0.3 + positionFactor * 0.2;
                colors[i3 + 2] = 0.7 + positionFactor * 0.3;
                
                // Add pulse influence for subtle breathing effect
                colors[i3] *= 0.8 + pulse * 0.2;
                colors[i3 + 1] *= 0.8 + pulse * 0.2;
                colors[i3 + 2] *= 0.8 + pulse * 0.2;
              }
              
              // Special color handling for shape modes
              if (shapeMode === 'entanglement' && entanglementPairs) {
                const pairedIndex = entanglementPairs[i];
                if (pairedIndex !== undefined && pairedIndex < particleCount) {
                  // Make entangled pairs share colors with subtle variations
                  if (i < pairedIndex) {
                    const j3 = pairedIndex * 3;
                    colors[j3] = colors[i3];
                    colors[j3 + 1] = colors[i3 + 1];
                    colors[j3 + 2] = colors[i3 + 2];
                  }
                }
              }
            }
            
            // Update connection lines - optimized for performance
            frameSkipCounter++;
            if (frameSkipCounter >= 3) {
              frameSkipCounter = 0;
              
              try {
                // Update connections with fewer lines for better performance
                const linePositions = [];
                const maxConnections = settings.maxConnections;
                let connectionCount = 0;
                
                // Different connection strategies for different modes
                if (shapeMode === 'entanglement' && entanglementPairs) {
                  // Draw lines only between entangled pairs
                  for (let i = 0; i < particleCount; i += 2) {
                    if (i + 1 >= particleCount) break; // Safety check
                    
                    const i3 = i * 3;
                    const j3 = (i + 1) * 3;
                    
                    linePositions.push(
                      positions[i3], positions[i3 + 1], positions[i3 + 2],
                      positions[j3], positions[j3 + 1], positions[j3 + 2]
                    );
                    connectionCount++;
                  }
                } else {
                  // Standard proximity-based connections
                  // Sample fewer particles based on screen fill for performance
                  const sampleRate = Math.max(2, Math.floor(particleCount / 500));
                  
                  for (let i = 0; i < particleCount; i += sampleRate) {
                    const i3 = i * 3;
                    const xi = positions[i3];
                    const yi = positions[i3 + 1];
                    const zi = positions[i3 + 2];
                    
                    for (let j = i + sampleRate; j < particleCount; j += sampleRate) {
                      if (connectionCount >= maxConnections) break;
                      
                      const j3 = j * 3;
                      const xj = positions[j3];
                      const yj = positions[j3 + 1];
                      const zj = positions[j3 + 2];
                      
                      const dx = xi - xj;
                      const dy = yi - yj;
                      const dz = zi - zj;
                      const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                      
                      if (dist < settings.connectionDistance) {
                        linePositions.push(xi, yi, zi, xj, yj, zj);
                        connectionCount++;
                      }
                    }
                  }
                }
                
                // Update connection lines if we have any
                if (linePositions.length > 0) {
                  const connectionsArray = new Float32Array(linePositions);
                  connectionsLines.geometry.setAttribute('position', new THREE.BufferAttribute(connectionsArray, 3));
                  
                  // Update connection counter display
                  currentConnectionCount = connectionCount;
                  document.getElementById('connection-count-display').textContent = connectionCount;
                }
                
                // Update connection opacity based on mode
                if (shapeMode === 'entanglement') {
                  connectionsLines.material.opacity = settings.connectionOpacity;
                } else {
                  connectionsLines.material.opacity = settings.connectionOpacity * 0.7;
                }
                
                // Add subtle glow effect to lines based on color mode
                if (colorMode === 'pulse') {
                  connectionsLines.material.color.setRGB(
                    0.3 + pulse * 0.2,
                    0.4 + pulse * 0.2,
                    0.8 + pulse * 0.2
                  );
                } else if (colorMode === 'quantum') {
                  connectionsLines.material.color.setRGB(
                    0.1 + pulse * 0.1,
                    0.5 + pulse * 0.2,
                    0.9
                  );
                }
              } catch (e) {
                console.error("Error updating connections:", e);
              }
            }
            
            // Rotate the scene slightly for a more dynamic view
            particleSystem.rotation.y += 0.001;
            connectionsLines.rotation.y += 0.001;
            
            // Update geometry attributes
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true;
            
            // Render the scene
            renderer.render(scene, camera);
          } catch (error) {
            console.error("Animation error:", error);
          }
        }

        // Event listeners
        function handleMouseMove(event) {
          const rect = renderer.domElement.getBoundingClientRect();
          mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;
          
          // Set flag for mouse movement
          mouseIsMoving = true;
          
          // Clear previous timeout and set new one
          clearTimeout(mouseMovementTimeout);
          mouseMovementTimeout = setTimeout(() => {
            mouseIsMoving = false;
          }, 100); // Assume mouse stopped after 100ms of no movement
        }

        window.addEventListener('mousemove', handleMouseMove);
        console.log("Mouse listener added");

        let resizeTimeout;
        function handleResize() {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(() => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            console.log("Window resized, renderer updated");
          }, 250);
        }

        window.addEventListener('resize', handleResize);
        console.log("Resize listener added");

        // Create UI sliders with tab organization
        function createSliders() {
          console.log("Creating UI sliders");
          const sliderConfigs = {
            particles: [
              { id: 'particleCount', label: 'Particle Count', min: 500, max: 8000, step: 100, reinit: true },
              { id: 'particleSize', label: 'Particle Size', min: 0.1, max: 0.8, step: 0.01 },
              { id: 'sphereRadius', label: 'Sphere Radius', min: 5, max: 30, step: 1 }
            ],
            interactions: [
              { id: 'connectionDistance', label: 'Connection Distance', min: 1, max: 10, step: 0.5 },
              { id: 'connectionOpacity', label: 'Connection Opacity', min: 0.1, max: 1, step: 0.05 },
              { id: 'maxConnections', label: 'Max Connections', min: 5000, max: 50000, step: 1000 },
              { id: 'interactionStrength', label: 'Interaction Strength', min: 0.01, max: 0.5, step: 0.01 },
              { id: 'interactionRadius', label: 'Interaction Radius', min: 5, max: 20, step: 1 }
            ],
            effects: [
              { id: 'movementSpeed', label: 'Movement Speed', min: 0.001, max: 0.05, step: 0.001 },
              { id: 'containmentForce', label: 'Containment Force', min: 0.01, max: 0.2, step: 0.01 },
              { id: 'velocityDamping', label: 'Velocity Damping', min: 0.8, max: 0.99, step: 0.01 },
              { id: 'pulseFrequency', label: 'Pulse Frequency', min: 0.1, max: 3.0, step: 0.1 },
              { id: 'pulseStrength', label: 'Pulse Strength', min: 0.01, max: 0.5, step: 0.01 },
              { id: 'quantumFluctuation', label: 'Quantum Fluctuation', min: 0.01, max: 0.2, step: 0.01 },
              { id: 'waveAmplitude', label: 'Wave Amplitude', min: 0.1, max: 3.0, step: 0.1 },
              { id: 'waveFrequency', label: 'Wave Frequency', min: 0.1, max: 2.0, step: 0.1 },
              { id: 'entanglementStrength', label: 'Entanglement Strength', min: 0.1, max: 1.0, step: 0.05 },
              { id: 'toroidRadius', label: 'Toroid Radius', min: 5, max: 20, step: 0.5 },
              { id: 'toroidTubeRadius', label: 'Toroid Tube Radius', min: 1, max: 6, step: 0.5 }
            ]
          };
          
          // Create sliders for each tab
          for (const [tabName, configs] of Object.entries(sliderConfigs)) {
            const tabContent = document.getElementById(`${tabName}-tab`);
            if (!tabContent) {
              console.error(`Tab content element #${tabName}-tab not found`);
              continue;
            }
            
            configs.forEach(config => {
              const container = document.createElement('div');
              container.className = 'slider-container';
              
              const header = document.createElement('div');
              header.className = 'slider-header';
              
              const label = document.createElement('label');
              label.textContent = config.label;
              
              const value = document.createElement('span');
              value.className = 'slider-value';
              value.id = `${config.id}-value`;
              value.textContent = settings[config.id].toFixed(2);
              
              const slider = document.createElement('input');
              slider.type = 'range';
              slider.min = config.min;
              slider.max = config.max;
              slider.step = config.step;
              slider.value = settings[config.id];
              slider.id = config.id;
              slider.dataset.setting = config.id; // For preset updates
              
              slider.addEventListener('input', (e) => {
                const newValue = parseFloat(e.target.value);
                settings[config.id] = newValue;
                value.textContent = newValue.toFixed(2);
                
                // Reinitialize particles if certain settings change
                if (config.reinit && !isInitializing) {
                  console.log(`Reinitializing for setting change: ${config.id} = ${newValue}`);
                  initParticles();
                }
                
                // Update connection material opacity
                if (config.id === 'connectionOpacity' && connectionsLines) {
                  connectionsLines.material.opacity = newValue * 0.7;
                }
                
                // Update particle size
                if (config.id === 'particleSize' && particleSystem) {
                  particleSystem.material.size = newValue;
                }
                
                // Handle shape-specific settings
                if ((config.id === 'toroidRadius' || config.id === 'toroidTubeRadius') && shapeMode === 'toroid') {
                  updateTargetPositions();
                }
              });
              
              header.appendChild(label);
              header.appendChild(value);
              container.appendChild(header);
              container.appendChild(slider);
              tabContent.appendChild(container);
            });
          }
          console.log("Sliders created successfully");
        }

        // Setup tab switching in settings panel
        document.querySelectorAll('.tab').forEach(tab => {
          tab.addEventListener('click', () => {
            const tabName = tab.getAttribute('data-tab');
            console.log(`Switching to tab: ${tabName}`);
            
            // Update active tab
            document.querySelectorAll('.tab').forEach(t => {
              t.classList.remove('active');
            });
            tab.classList.add('active');
            
            // Show selected tab content, hide others
            document.querySelectorAll('.tab-content').forEach(content => {
              content.style.display = 'none';
            });
            document.getElementById(`${tabName}-tab`).style.display = 'block';
            
            activeTab = tabName;
          });
        });
        console.log("Tab listeners set up");

        // Setup shape mode buttons with animation effect
        document.querySelectorAll('#shapeModes button').forEach(button => {
          button.addEventListener('click', () => {
            const mode = button.getAttribute('data-mode');
            console.log(`Changing shape mode to: ${mode}`);
            
            // Only take action if the mode is changing
            if (shapeMode !== mode) {
              shapeMode = mode;
              
              // Clear existing target positions to trigger an update
              targetPositions = null;
              
              // Add button animation effect
              const buttons = document.querySelectorAll('#shapeModes button');
              buttons.forEach(btn => btn.classList.remove('active'));
              button.classList.add('active');
              
              // Scale button effect
              gsap.fromTo(button, 
                { scale: 1 }, 
                { scale: 1.1, duration: 0.2, yoyo: true, repeat: 1 }
              );
              
              // Flash particle system
              gsap.fromTo(
                particleSystem.material, 
                { opacity: 0.9 }, 
                { opacity: 1, duration: 0.3, yoyo: true, repeat: 1 }
              );
              
              // Reinitialize for entanglement to set up pairs
              if (mode === 'entanglement') {
                console.log("Reinitializing for entanglement mode");
                initParticles();
              }
            }
          });
        });
        console.log("Shape mode buttons set up");

        // Setup color mode buttons with animation effect
        document.querySelectorAll('#colorModes button').forEach(button => {
          button.addEventListener('click', () => {
            const mode = button.getAttribute('data-mode');
            console.log(`Changing color mode to: ${mode}`);
            
            if (colorMode !== mode) {
              colorMode = mode;
              
              // Update active button
              const buttons = document.querySelectorAll('#colorModes button');
              buttons.forEach(btn => btn.classList.remove('active'));
              button.classList.add('active');
              
              // Handle custom color picker visibility
              const colorCustomizer = document.getElementById('colorCustomizer');
              if (colorCustomizer) {
                if (mode === 'custom') {
                  colorCustomizer.style.display = 'flex';
                  
                  // Initialize color pickers if they haven't been already
                  if (!window.colorPickersInitialized) {
                    const baseColorPicker = document.getElementById('baseColorPicker');
                    const secondaryColorPicker = document.getElementById('secondaryColorPicker');
                    const colorVarianceSlider = document.getElementById('colorVarianceSlider');
                    
                    if (baseColorPicker && secondaryColorPicker && colorVarianceSlider) {
                      // Create custom color settings if they don't exist
                      if (!settings.customColors) {
                        settings.customColors = {
                          baseColor: { r: 0.37, g: 0.6, b: 1.0 },  // #5e9eff
                          secondaryColor: { r: 1.0, g: 0.25, b: 0.51 }, // #ff4081
                          variance: 0.3
                        };
                      }
                      
                      // Handle base color changes
                      baseColorPicker.addEventListener('input', (e) => {
                        const hexColor = e.target.value;
                        // Convert hex to RGB (0-1 range)
                        const r = parseInt(hexColor.slice(1, 3), 16) / 255;
                        const g = parseInt(hexColor.slice(3, 5), 16) / 255;
                        const b = parseInt(hexColor.slice(5, 7), 16) / 255;
                        
                        settings.customColors.baseColor = { r, g, b };
                      });
                      
                      // Handle secondary color changes
                      secondaryColorPicker.addEventListener('input', (e) => {
                        const hexColor = e.target.value;
                        // Convert hex to RGB (0-1 range)
                        const r = parseInt(hexColor.slice(1, 3), 16) / 255;
                        const g = parseInt(hexColor.slice(3, 5), 16) / 255;
                        const b = parseInt(hexColor.slice(5, 7), 16) / 255;
                        
                        settings.customColors.secondaryColor = { r, g, b };
                      });
                      
                      // Handle variance slider
                      colorVarianceSlider.addEventListener('input', (e) => {
                        settings.customColors.variance = parseFloat(e.target.value);
                      });
                      
                      window.colorPickersInitialized = true;
                    }
                  }
                } else {
                  colorCustomizer.style.display = 'none';
                }
              }
              
              // Add button animation
              gsap.fromTo(button, 
                { scale: 1 }, 
                { scale: 1.1, duration: 0.2, yoyo: true, repeat: 1 }
              );
              
              // Apply color transition effect
              let hueRotate = 0;
              switch(mode) {
                case 'spectrum': hueRotate = 90; break;
                case 'pulse': hueRotate = 180; break;
                case 'quantum': hueRotate = 270; break;
              }
              
              // Apply hue rotation effect to particles
              if (particleSystem) {
                gsap.fromTo(
                  particleSystem.material,
                  { opacity: 0.8 },
                  { opacity: 1, duration: 0.5, ease: "power2.out" }
                );
              }
            }
          });
        });
        console.log("Color mode buttons set up");
        
        // Fullscreen toggle
        document.getElementById('fullscreenBtn').addEventListener('click', () => {
          console.log("Toggling fullscreen");
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
              console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
          } else {
            if (document.exitFullscreen) {
              document.exitFullscreen();
            }
          }
        });

        // Initialize and start animation
        try {
          console.log("Starting initialization");
          initParticles();
          createSliders();
          animate();
          console.log("Initialization complete, animation started");
        } catch (e) {
          console.error("Initialization error:", e.message, e.stack);
          hideLoading();
          alert("There was an error initializing the simulation. Please try refreshing the page.");
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
          console.log("Page unloading, cleaning up resources");
          if (animationId) {
            cancelAnimationFrame(animationId);
          }
          
          if (particleSystem) {
            scene.remove(particleSystem);
            scene.remove(connectionsLines);
            
            particleSystem.geometry.dispose();
            particleSystem.material.dispose();
            connectionsLines.geometry.dispose();
            connectionsLines.material.dispose();
            renderer.dispose();
          }
          
          window.removeEventListener('mousemove', handleMouseMove);
          window.removeEventListener('resize', handleResize);
        });
        
        console.log("Setup complete");
      } catch (error) {
        console.error("Critical initialization error:", error.message, error.stack);
        hideLoading();
        alert("Failed to initialize the quantum simulator: " + error.message);
      }
    });
  </script>
  
  <!-- Load animations.js as module -->
  <script type="module">
    import * as THREE from 'three';
    
    // All UI animation functions
    document.addEventListener('DOMContentLoaded', () => {
      setupUIAnimations();
      setupLoadingAnimations();
      initAnimations();
      
      // Setup audio controls if available
      if (window.audioControls && typeof window.audioControls.setup === 'function') {
        window.audioControls.setup();
      }
    });
    
    // Enhanced UI animations
    function setupUIAnimations() {
      // Panel hover effects
      gsap.utils.toArray('.control-panel').forEach(panel => {
        panel.addEventListener('mouseenter', () => {
          gsap.to(panel, {
            boxShadow: '0 8px 40px var(--panel-glow), inset 0 0 0 1px rgba(255, 255, 255, 0.1)',
            scale: 1.02,
            duration: 0.3,
            ease: 'power2.out'
          });
          
          // Animate corner brackets
          const brackets = panel.querySelectorAll('::before, ::after');
          gsap.to(brackets, {
            width: '40px',
            height: '40px',
            opacity: 0.6,
            duration: 0.3,
            ease: 'power2.out'
          });
        });
        
        panel.addEventListener('mouseleave', () => {
          gsap.to(panel, {
            boxShadow: '0 4px 30px var(--panel-glow), inset 0 0 0 1px rgba(255, 255, 255, 0.05)',
            scale: 1,
            duration: 0.3,
            ease: 'power2.out'
          });
          
          // Animate corner brackets back
          const brackets = panel.querySelectorAll('::before, ::after');
          gsap.to(brackets, {
            width: '30px',
            height: '30px',
            opacity: 0.4,
            duration: 0.3,
            ease: 'power2.out'
          });
        });
      });
      
      // Button hover animations
      gsap.utils.toArray('button').forEach(button => {
        button.addEventListener('mouseenter', () => {
          gsap.to(button, {
            backgroundColor: 'rgba(58, 123, 213, 0.15)',
            borderColor: 'var(--primary-light)',
            color: 'var(--text-primary)',
            y: -2,
            boxShadow: '0 4px 12px rgba(58, 123, 213, 0.2)',
            duration: 0.15,
            ease: 'power1.out'
          });
          
          // Enhance button glow effect
          gsap.to(button.querySelector('::after'), {
            opacity: 0.6,
            duration: 0.15,
            ease: 'power1.out'
          });
        });
        
        button.addEventListener('mouseleave', () => {
          if (!button.classList.contains('active')) {
            gsap.to(button, {
              backgroundColor: 'rgba(10, 14, 23, 0.8)',
              borderColor: 'var(--panel-border)',
              color: 'var(--text-secondary)',
              y: 0,
              boxShadow: 'none',
              duration: 0.15,
              ease: 'power1.out'
            });
          } else {
            gsap.to(button, {
              backgroundColor: 'rgba(58, 123, 213, 0.25)',
              borderColor: 'var(--primary-light)',
              color: 'var(--tertiary)',
              y: 0,
              boxShadow: '0 0 15px rgba(58, 123, 213, 0.3)',
              duration: 0.15,
              ease: 'power1.out'
            });
          }
          
          // Reduce button glow
          gsap.to(button.querySelector('::after'), {
            opacity: 0.3,
            duration: 0.15,
            ease: 'power1.out'
          });
        });
        
        button.addEventListener('mousedown', () => {
          gsap.to(button, {
            scale: 0.95,
            duration: 0.1,
            ease: 'power1.in'
          });
        });
        
        button.addEventListener('mouseup', () => {
          gsap.to(button, {
            scale: 1,
            duration: 0.1,
            ease: 'power1.out'
          });
        });
      });
      
      // Slider animations
      gsap.utils.toArray('input[type="range"]').forEach(slider => {
        slider.addEventListener('mousedown', () => {
          const valueDisplay = document.getElementById(`${slider.id}-value`);
          if (valueDisplay) {
            gsap.to(valueDisplay, {
              scale: 1.1,
              backgroundColor: 'rgba(0, 210, 255, 0.2)',
              color: 'var(--tertiary)',
              duration: 0.2,
              ease: 'power1.out'
            });
          }
        });
        
        slider.addEventListener('mouseup', () => {
          const valueDisplay = document.getElementById(`${slider.id}-value`);
          if (valueDisplay) {
            gsap.to(valueDisplay, {
              scale: 1,
              backgroundColor: 'rgba(0, 210, 255, 0.1)',
              color: 'var(--tertiary)',
              duration: 0.2,
              ease: 'power1.out'
            });
          }
        });
      });
      
      // Tab switching animations
      gsap.utils.toArray('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
          const tabId = tab.getAttribute('data-tab');
          const tabContent = document.getElementById(`${tabId}-tab`);
          
          // Hide all tab content with animation
          gsap.utils.toArray('.tab-content').forEach(content => {
            if (content.id !== `${tabId}-tab`) {
              gsap.to(content, {
                opacity: 0,
                y: -10,
                duration: 0.2,
                ease: 'power1.in',
                onComplete: () => {
                  content.style.display = 'none';
                }
              });
            }
          });
          
          // Show selected tab content with animation
          tabContent.style.display = 'block';
          gsap.fromTo(
            tabContent,
            { opacity: 0, y: 10 },
            { opacity: 1, y: 0, duration: 0.3, ease: 'power2.out' }
          );
        });
      });
      
      // Fullscreen button animation
      const fullscreenBtn = document.getElementById('fullscreenBtn');
      if (fullscreenBtn) {
        fullscreenBtn.addEventListener('mouseenter', () => {
          gsap.to(fullscreenBtn, {
            backgroundColor: 'rgba(58, 123, 213, 0.15)',
            borderColor: 'var(--primary-light)',
            scale: 1.05,
            y: -2,
            boxShadow: '0 6px 20px rgba(58, 123, 213, 0.25)',
            duration: 0.2,
            ease: 'power1.out'
          });
        });
        
        fullscreenBtn.addEventListener('mouseleave', () => {
          gsap.to(fullscreenBtn, {
            scale: 1,
            y: 0,
            boxShadow: '0 4px 12px rgba(0, 0, 0, 0.2)',
            duration: 0.2,
            ease: 'power1.out'
          });
        });
      }
    });
  </script>
  
  <!-- Chat Integration Script -->
  <script>
    // Global chat simulator connection
    let simulator = null;
    let chatInterface = null;
    
    // Create chat components
    function createChatComponents() {
      const chatBtn = document.getElementById('chatBtn');
      const chatClose = document.getElementById('chatClose');
      const chatOverlay = document.getElementById('chatOverlay');
      
      // Setup toggle functionality
      if (chatBtn) {
        chatBtn.addEventListener('click', () => {
          chatOverlay.classList.add('visible');
        });
      } else {
        console.error("Chat button not found!");
      }
      
      if (chatClose) {
        chatClose.addEventListener('click', () => {
          chatOverlay.classList.remove('visible');
        });
      }
      
      // Initialize chatbot
      chatInterface = new QuantumChatbot({
        containerId: 'chatOverlay',
        messagesId: 'chatMessages',
        inputId: 'chatInput',
        sendButtonId: 'chatSend',
        toggleButtonId: 'chatBtn',
        apiOptions: {
          useLocalFallback: true
        },
        systemPrompt: "You are a quantum physics assistant helping users understand the quantum particle simulation they're viewing."
      });
      
      // Store reference to chat interface globally
      window.chatInterface = chatInterface;
      
      console.log("Chat components initialized");
      return chatInterface;
    }
    
    // Get current simulation data (used by chatbot)
    function getSimulationData() {
      // This function will be called by the chatbot to get info about the current simulation
      try {
        // Get settings from global window if available
        const settings = window.simulationSettings || {
          particleCount: 1500,
          mode: 'vortex',
          colorMode: 'spectrum'
        };
        
        return {
          particleCount: settings.particleCount,
          mode: settings.mode,
          colorMode: settings.colorMode,
          fps: document.getElementById('fps-display') ? 
            document.getElementById('fps-display').textContent : '60',
          connections: document.getElementById('connection-count-display') ?
            document.getElementById('connection-count-display').textContent : '0'
        };
      } catch (err) {
        console.error("Error getting simulation data:", err);
        return {
          particleCount: 1500,
          mode: 'default',
          colorMode: 'default'
        };
      }
    }
    
    // Initialize chat when document is loaded
    document.addEventListener('DOMContentLoaded', () => {
      // Wait a bit for the simulation to initialize first
      setTimeout(() => {
        createChatComponents();
        
        // Create welcome message
        setTimeout(() => {
          // Add a welcome message
          if (window.chatInterface && window.chatInterface.addBotMessage) {
            window.chatInterface.addBotMessage(
              "Welcome to the Quantum Simulator! I'm your quantum physics assistant. " +
              "Feel free to ask questions about the simulation or quantum physics concepts."
            );
            
            // Pulse the chat button to draw attention
            const chatBtn = document.getElementById('chatBtn');
            if (chatBtn) {
              chatBtn.style.animation = 'pulse 1s 3';
            }
          }
        }, 3000);
      }, 2000);
    });
  </script>
</body>
</html>